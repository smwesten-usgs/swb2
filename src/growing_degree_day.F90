module growing_degree_day

  use iso_c_binding

  use constants_and_conversions
  use datetime                   , only : mmdd2doy
  use exceptions
  use netcdf4_support
  use parameters
  use simulation_datetime
  use fstring_list
  implicit none

  private

  public :: GDD_BASE, GDD_MAX, GDD_RESET_DATE
  public :: growing_degree_day_calculate, growing_degree_day_initialize
  public :: modified_growing_degree_day_calculate

  real (c_float), allocatable  :: GDD_BASE(:)
  real (c_float), allocatable  :: GDD_MAX(:)
  integer (c_int), allocatable :: GDD_RESET_DATE(:)
  type (T_NETCDF4_FILE), pointer    :: pNCFILE

contains

  subroutine growing_degree_day_initialize( is_cell_active, landuse_index )

    logical (c_bool), intent(in)     :: is_cell_active(:,:)
    integer (c_int), intent(in)      :: landuse_index(:)

    ! [ LOCALS ]
    integer (c_int)              :: status
    integer (c_int)              :: indx
    type (FSTRING_LIST_T)              :: parameter_list
    type (FSTRING_LIST_T)              :: gdd_reset_val_list
    character (len=32)                :: sBuf
    real (c_float), allocatable  :: gdd_base_l(:)
    real (c_float), allocatable  :: gdd_max_l(:)
    integer (c_int)              :: number_of_landuse_codes
    integer (c_int), allocatable :: landuse_code(:)

    allocate( GDD_BASE( count( is_cell_active ) ), stat=status )
    call assert( status == 0, "Problem allocating memory", __FILE__, __LINE__ )

    allocate( GDD_MAX( count( is_cell_active ) ), stat=status )
    call assert( status == 0, "Problem allocating memory", __FILE__, __LINE__ )

    !> create string list that allows for alternate heading identifiers for the landuse code
    call parameter_list%append("LU_Code")
    call parameter_list%append("Landuse_Code")
    call parameter_list%append("Landuse_Lookup_Code")

    !> Determine how many landuse codes are present
    call PARAMS%get_parameters( slKeys=parameter_list, iValues=landuse_code )
    number_of_landuse_codes = count( landuse_code >= 0 )
    call parameter_list%clear()

    call parameter_list%append("GDD_Base_Temp")
    call parameter_list%append("GDD_Base_Temperature")
    call parameter_list%append("GDD_Base")

    call PARAMS%get_parameters( slKeys=parameter_list, fValues=gdd_base_l )
    call parameter_list%clear()

    call parameter_list%append("GDD_Max_Temp")
    call parameter_list%append("GDD_Maximum_Temperature")
    call parameter_list%append("GDD_Maximum_Temp")
    call parameter_list%append("GDD_Max")

    call PARAMS%get_parameters( slKeys=parameter_list, fValues=gdd_max_l )
    call parameter_list%clear()

    call parameter_list%append("GDD_Reset_Date")
    call parameter_list%append("GDD_Reset")

    call PARAMS%get_parameters( slKeys=parameter_list, slValues=gdd_reset_val_list )
    call parameter_list%clear()

    allocate( GDD_RESET_DATE( count( is_cell_active ) ), stat=status )
    call assert( status==0, "Problem allocating memory.", __FILE__, __LINE__ )

    if ( gdd_reset_val_list%count == number_of_landuse_codes      &
         .and. gdd_reset_val_list%count_matching("<NA>") == 0 ) then

      ! retrieve gdd reset values; convert mm/dd to DOY
      do indx=1, gdd_reset_val_list%count
        sBuf = gdd_reset_val_list%get( indx )

        where ( landuse_index == indx )
          GDD_RESET_DATE = mmdd2doy( sBuf, "GDD_RESET_DATE" )
        end where

      enddo

    else

      ! if no GDD_RESET_DATE found in parameter tables, assign the default: reset GDD at end of calendar year
      GDD_RESET_DATE = 365_c_int

    endif


    if ( ubound( gdd_max_l, 1 ) == number_of_landuse_codes        &
        .and. gdd_max_l(1) > rTINYVAL ) then

      do indx=1, ubound( landuse_index, 1)
        GDD_MAX( indx ) = gdd_max_l( landuse_index( indx ) )
      enddo

    else

      ! if no GDD_MAX found in parameter tables, assign the default FAO-56 value
      GDD_MAX = 86.0_c_float

    endif


    if ( ubound( gdd_base_l, 1 ) == number_of_landuse_codes        &
        .and. gdd_base_l(1) > rTINYVAL  ) then

      do indx=1, ubound( landuse_index, 1)
        GDD_BASE( indx ) = gdd_base_l( landuse_index( indx ) )
      enddo

    else

      ! if no GDD_Base found in parameter tables, assign the default FAO-56 value
      GDD_BASE = 50.0_c_float

    endif

  end subroutine growing_degree_day_initialize

!--------------------------------------------------------------------------------------------------

  impure elemental subroutine growing_degree_day_calculate( gdd, tmean, order )

    ! [ ARGUMENTS ]
    real (c_float), intent(inout)       :: gdd
    real (c_float), intent(in)          :: tmean
    integer (c_int), intent(in)         :: order

    associate( doy_to_reset_gdd => GDD_RESET_DATE( order ),         &
               gdd_max => GDD_MAX( order ),                         &
               gdd_base => GDD_BASE( order ) )

      if ( SIM_DT%iDOY == doy_to_reset_gdd )  gdd = 0.0_c_float
      
      gdd = gdd + max(tmean, gdd_base) - gdd_base

    end associate

  end subroutine growing_degree_day_calculate

!--------------------------------------------------------------------------------------------------

  impure elemental subroutine modified_growing_degree_day_calculate( gdd, tmin, tmax, order )

  ! [ ARGUMENTS ]
  real (c_float), intent(inout)       :: gdd
  real (c_float), intent(in)          :: tmin
  real (c_float), intent(in)          :: tmax
  integer (c_int), intent(in)         :: order

  associate( doy_to_reset_gdd => GDD_RESET_DATE( order ),         &
             gdd_max => GDD_MAX( order ),                         &
             gdd_base => GDD_BASE( order ) )

    if ( SIM_DT%iDOY == doy_to_reset_gdd )  gdd = 0.0_c_float
    
    gdd = gdd + max((max(tmin, gdd_base) + min(tmax,gdd_max))/2.0_c_float, gdd_base) - gdd_base

  end associate

end subroutine modified_growing_degree_day_calculate

end module growing_degree_day
