!> @file
!!  Contain a single module, @ref netcdf4_support, which
!!  provides support for use of netCDF files as input or output.
!!
!! Supports use of netCDF files as input for time-varying,
!! gridded meteorlogic data, or output for any SWB-generated variable.
!!
!! from the C API:
!! The @c nc_get_vars_l type family of functions read a subsampled (strided)
!! array section of values from a netCDF variable of an open netCDF dataset.
!! The subsampled array section is specified by giving a corner,
!! a vector of edge lengths, and a stride vector. The values are read
!! with the last dimension of the netCDF variable varying fastest.
!!          ^^^^                                  ^^^^^^^ ^^^^^^^
!!
!! from the Fortran 90 API:
!! The values to be read are associated with the netCDF variable by
!! assuming that the first dimension of the netCDF variable
!!                   ^^^^^
!! varies fastest in the Fortran 90 interface.
!! ^^^^^^ ^^^^^^^

!> Provide support for use of netCDF files as input for time-varying,
!! gridded meteorlogic data, or output for any SWB-generated variable.
module netcdf4_support

  use iso_c_binding
  use constants_and_conversions
  use exceptions
  use logfiles
  use netcdf_c_api_interfaces
  use fstring
  use fstring_list, only           : FSTRING_LIST_T
  use PROJ4_support, only         : create_attributes_from_proj4_string
  use datetime

  use version_control, only  : SWB_VERSION, GIT_COMMIT_HASH_STRING,           &
                               GIT_BRANCH_STRING, COMPILE_DATE, COMPILE_TIME, &
                               COMPILATION_TIMESTAMP

  use grid
!  use typesizes
  use netcdf_c_api_interfaces

  implicit none

  private

  public :: NC_FLOAT, NC_FILL_FLOAT, NC_FILL_INT

  integer(c_int), public :: NC_READONLY          = 0
  integer(c_int), public :: NC_READWRITE         = 1

  ! from netcdf.h:

  ! #define NC_NAT          0
  ! #define NC_BYTE         1
  ! #define NC_CHAR         2
  ! #define NC_SHORT        3
  ! #define NC_INT          4
  ! #define NC_LONG         NC_INT
  ! #define NC_FLOAT        5
  ! #define NC_DOUBLE       6
  ! #define NC_UBYTE        7
  ! #define NC_USHORT       8
  ! #define NC_UINT         9
  ! #define NC_INT64        10
  ! #define NC_UINT64       11
  ! #define NC_STRING       12

  integer(c_int), parameter ::  NC_NAT    = 0
  integer(c_int), parameter ::  NC_BYTE   = 1
  integer(c_int), parameter ::  NC_CHAR   = 2
  integer(c_int), parameter ::  NC_SHORT  = 3
  integer(c_int), parameter ::  NC_INT    = 4
  integer(c_int), parameter ::  NC_LONG   = NC_INT
  integer(c_int), parameter ::  NC_FLOAT  = 5
  integer(c_int), parameter ::  NC_DOUBLE = 6
  integer(c_int), parameter ::  NC_UBYTE  = 7
  integer(c_int), parameter ::  NC_USHORT = 8
  integer(c_int), parameter ::  NC_UINT   = 9
  integer(c_int), parameter ::  NC_INT64  = 10
  integer(c_int), parameter ::  NC_UINT64 = 11
  integer(c_int), parameter ::  NC_STRING = 12

  integer(c_int), parameter :: NC_FILL_CHAR    = 0
  integer(c_int), parameter :: NC_FILL_BYTE    = -127
  integer(c_int), parameter :: NC_FILL_SHORT   = -32767
  integer(c_int), parameter :: NC_FILL_INT     = -2147483647
  integer(c_int), parameter :: NC_NA_INT       = -9999

  real(c_float),  parameter :: NC_FILL_FLOAT   = -9999.0_c_float
  real(c_double), parameter :: NC_FILL_DOUBLE  = -9.9e-20_c_double
!  real(c_float),  parameter :: NC_FILL_FLOAT   = -( HUGE( 0_c_float ) - 1.0_c_float )
!  real(c_double), parameter :: NC_FILL_DOUBLE  = -( HUGE( 0_c_double ) - 1.0_c_double )

  ! mode flags for opening and creating datasets
  integer(c_int), parameter :: NC_NOWRITE          = 0
  integer(c_int), parameter :: NC_WRITE            = 1
  integer(c_int), parameter :: NC_CLOBBER          = 0
  integer(c_int), parameter :: NC_NOCLOBBER        = 4
  integer(c_int), parameter :: NC_FILL             = 0
  integer(c_int), parameter :: NC_NOFILL           = 256
  integer(c_int), parameter :: NC_LOCK             = 1024
  integer(c_int), parameter :: NC_SHARE            = 2048
  integer(c_int), parameter :: NC_STRICT_NC3       = 8
  integer(c_int), parameter :: NC_64BIT_OFFSET     = 512
  integer(c_int), parameter :: NC_SIZEHINT_DEFAULT = 0
  integer(c_int), parameter :: NC_ALIGN_CHUNK      = -1
  integer(c_int), parameter :: NC_FORMAT_CLASSIC   = 1
  integer(c_int), parameter :: NC_FORMAT_64BIT     = 2
  integer(c_int), parameter :: NC_FORMAT_NETCDF4   = 3
  integer(c_int), parameter :: NC_FORMAT_NETCDF4_CLASSIC = 4

  ! implementation limits (warning!  should be the same as c interface)
  integer(c_int), parameter :: NC_MAX_DIMS     = 1024
  integer(c_int), parameter :: NC_MAX_ATTRS    = 8192
  integer(c_int), parameter :: NC_MAX_VARS     = 8192
  integer(c_int), parameter :: NC_MAX_NAME     = 256

  integer (c_int), parameter :: NC_SHUFFLE_YES = 1
  integer (c_int), parameter :: NC_SHUFFLE_NO = 0
  integer (c_int), parameter :: NC_DEFLATE_YES = 1
  integer (c_int), parameter :: NC_DEFLATE_NO = 0

  integer(c_int), parameter :: NC_NETCDF4        = 4096
  integer(c_int), parameter :: NC_CLASSIC_MODEL  = 256


  integer(c_int),  parameter :: NC_UNLIMITED = 0
  integer(c_int),  parameter :: NC_GLOBAL    = -1

  !> @TODO: implement a more flexible way of tracking
  !!        variable IDs; presently the code can break if
  !!        lat and lon are omitted, but time_bnds is included;
  !!        this is because if the lat and lon variables are
  !!        not defined, NC_TIME_BNDS may be 4 or 5 or some other value.
  integer (c_int), public, parameter :: NC_TIME      = 0
  integer (c_int), public, parameter :: NC_Y         = 1
  integer (c_int), public, parameter :: NC_X         = 2
  integer (c_int), public, parameter :: NC_Z         = 3
  integer (c_int), public, parameter :: NC_AUX       = 3
  integer (c_int), public, parameter :: NC_CRS       = 4
  integer (c_int), public, parameter :: NC_LAT       = 5
  integer (c_int), public, parameter :: NC_LON       = 6
  integer (c_int), public            :: NC_TIME_BNDS = 7

  integer (c_int), parameter :: NC_FIRST = 0
  integer (c_int), parameter :: NC_LAST  = 1
  integer (c_int), parameter :: NC_BY    = 2

  integer (c_int), public, parameter :: NC_LEFT  = 0
  integer (c_int), public, parameter :: NC_RIGHT = 1
  integer (c_int), public, parameter :: NC_TOP    = 0
  integer (c_int), public, parameter :: NC_BOTTOM = 1

  integer (c_int), parameter :: COLUMN = 1
  integer (c_int), parameter :: ROW = 2

  integer (c_int), parameter :: LEAP_YEAR = 0
  integer (c_int), parameter :: NOLEAP_YEAR = 1
  integer (c_int), parameter :: YEAR_IS_360_DAYS = 2 

  character (len=25), dimension(4), parameter :: NETCDF_FORMAT_STRING = &
    ["NC_FORMAT_CLASSIC        ", &
     "NC_FORMAT_64BIT          ", &
     "NC_FORMAT_NETCDF4        ", &
     "NC_FORMAT_NETCDF4_CLASSIC" ]

  character (len=6), dimension(0:6), parameter :: NETCDF_DATA_TYPE = &
    ["nat   ", &
     "byte  ", &
     "char  ", &
     "short ", &
     "int   ", &
     "float ", &
     "double" ]

  type T_NETCDF_DIMENSION
    character (len=64)      :: sDimensionName
    integer (c_int)    :: iNC_DimID = NC_NA_INT
    integer (c_size_t) :: iNC_DimSize
    logical (c_bool)   :: lUnlimited = FALSE
  end type T_NETCDF_DIMENSION

  type T_NETCDF_ATTRIBUTE
    character (len=64) :: sAttributeName
    character (len=256), dimension(:), allocatable    :: sAttValue
    integer (c_short), dimension(:), allocatable :: i2AttValue
    integer (c_int), dimension(:), allocatable   :: iAttValue
    real (c_float), dimension(:), allocatable    :: rAttValue
    real (c_double), dimension(:), allocatable   :: dpAttValue
    integer (c_int) :: iNC_AttType
    integer (c_size_t) :: iNC_AttSize
  end type T_NETCDF_ATTRIBUTE

  type T_NETCDF_VARIABLE
    character (len=64) :: sVariableName
    integer (c_int) :: iNC_VarID = NC_NA_INT
    integer (c_int) :: iNC_VarType
    integer (c_int) :: iNumberOfDimensions
    integer (c_int), dimension(0:3) :: iNC_DimID = NC_NA_INT
    integer (c_int) :: iNumberOfAttributes
    type (T_NETCDF_ATTRIBUTE), dimension(:), pointer :: pNC_ATT => null()
  end type T_NETCDF_VARIABLE

  type T_NETCDF4_FILE
    integer (c_int) :: iNCID
    character (len=256)  :: sFilename
    integer (c_int) :: iFileFormat
    integer (c_int) :: iNumberOfDimensions
    integer (c_int) :: iNumberOfVariables
    integer (c_int) :: iNumberOfAttributes
    integer (c_int) :: iNC3_UnlimitedDimensionNumber
    integer (c_int) :: iOriginJD   = NC_NA_INT
    integer (c_int) :: iFirstDayJD = NC_NA_INT
    integer (c_int) :: iLastDayJD  = NC_NA_INT
    integer (c_int) :: iOriginMonth
    integer (c_int) :: iOriginDay
    integer (c_int) :: iOriginYear
    integer (c_int) :: iOriginHH
    integer (c_int) :: iOriginMM
    integer (c_int) :: iOriginSS
    integer (c_int) :: lLeapYearTreatment = LEAP_YEAR
    integer (c_size_t), dimension(0:3) :: iStart
    integer (c_size_t), dimension(0:3) :: iCount
    integer (c_size_t), dimension(0:3) :: iStride = 1
    integer (c_size_t), dimension(0:1) :: iColBounds
    integer (c_size_t), dimension(0:1) :: iRowBounds
    integer (c_int) :: iNX
    integer (c_int) :: iNY
    character (len=3) :: sVariableOrder = "tyx"
    real (c_double), dimension(0:1) :: rX
    real (c_double), dimension(0:1) :: rY
    real (c_double)   :: rCoordinateTolerance = 0.0_c_double  ! set this to be > 0.0 to allow some 'slop' when comparing coordinates
    logical (c_bool)  :: lX_IncreasesWithIndex = TRUE
    logical (c_bool)  :: lY_IncreasesWithIndex = FALSE
    logical (c_bool)  :: lAllowAutomaticDataFlipping = TRUE

    real (c_double), dimension(0:1) :: dpFirstAndLastTimeValues
    character (len=64), dimension(0:3) :: sVarName = ["time","y   ","x   ","z   "]
    integer (c_int), dimension(0:3) :: iVarID = NC_NA_INT
    integer (c_int), dimension(0:3) :: iVarIndex = NC_NA_INT
    integer (c_int), dimension(0:3) :: iVarType = NC_NA_INT
    character (len=64), dimension(0:3) :: sVarUnits = "NA"
    integer (c_int), dimension(0:3, 0:3) :: iVar_DimID = NC_NA_INT
    real (c_double), dimension(0:3) :: rScaleFactor = 1.0_c_double
    real (c_double), dimension(0:3) :: rAddOffset = 0.0_c_double
    integer (c_int), dimension(0:2) :: iRowIter
    integer (c_int), dimension(0:2) :: iColIter
    logical (c_bool) :: lFlipHorizontal = FALSE
    logical (c_bool) :: lFlipVertical = FALSE

    real (c_double), allocatable, dimension(:) :: rX_Coords
    real (c_double), allocatable, dimension(:) :: rY_Coords
    real (c_double)                            :: rX_Coord_AddOffset = 0.0_c_double
    real (c_double)                            :: rY_Coord_AddOffset = 0.0_c_double
    real (c_double), allocatable, dimension(:) :: rDateTimeValues
    real (c_double) :: rGridCellSizeX
    real (c_double) :: rGridCellSizeY

    type (T_NETCDF_DIMENSION), dimension(:), pointer :: pNC_DIM => null()
    type (T_NETCDF_VARIABLE), dimension(:), pointer  :: pNC_VAR => null()
    type (T_NETCDF_ATTRIBUTE), dimension(:), pointer :: pNC_ATT => null()
  end type T_NETCDF4_FILE

!
! For a netCDF file to be read successfully, the reader must have a way to
! tie coordinate values to index values. By default the code assumes that coordinates
! decrease while the indices increase (i.e. read the file in as rows from top to bottom).
!
! If this is not the case, the data/coordinates must be 'flipped' relative to one another.
!
! DEFAULT ASSUMPTION REGARDING VERTICAL COORDINATES
!
!                  /\
!  coordinates     |   |
!  increase        |   |
!  in upward       |   |
!  direction       |   |
!                  |   |
!                  |   | column index increases in downward direction
!                  |   |
!                  |   |
!                      \/
!

  public :: T_NETCDF_DIMENSION, T_NETCDF_VARIABLE, T_NETCDF_ATTRIBUTE
  public :: T_NETCDF4_FILE

  public :: netcdf_get_attribute_list_for_variable
  public :: netcdf_open_and_prepare_for_merging
  public :: netcdf_open_and_prepare_as_input
  public :: netcdf_open_and_prepare_as_output_archive
  public :: netcdf_open_and_prepare_as_output
  public :: netcdf_date_within_range
  public :: netcdf_deallocate_data_struct
  public :: netcdf_nullify_data_struct
  public :: netcdf_dump_cdl
  public :: netcdf_open_file
  public :: netcdf_close_file
  public :: netcdf_get_variable_list
  public :: netcdf_get_variable_slice
  public :: netcdf_update_time_starting_index
  public :: netcdf_put_variable_array
  public :: netcdf_put_packed_variable_array
  public :: netcdf_put_variable_vector
  public :: netcdf_coord_to_col_row
  public :: netcdf_set_coordinate_tolerance
  public :: netcdf_get_variable_id_for_variable
  public :: netcdf_rewrite_attribute

contains

!----------------------------------------------------------------------

function netcdf_date_within_range( NCFILE, iJulianDay)  result( lWithinRange )

  type (T_NETCDF4_FILE ) :: NCFILE
  integer (c_int) :: iJulianDay
  logical (c_bool) :: lWithinRange

  if ( iJulianDay >= NCFILE%iFirstDayJD &
      .and. iJulianDay <= NCFILE%iLastDayJD ) then

    lWithinRange = TRUE

  else

    lWithinRange = FALSE

  endif

end function netcdf_date_within_range

!----------------------------------------------------------------------

!> We need two functions to convert from index to timeval, and timeval to JD;
!> note that timeval refers to the number of days from the origin
!> of the netCDF file

!> return the day value (number of days since origin
function nf_julian_day_to_index(NCFILE, rJulianDay)  result (iIndex)

  type (T_NETCDF4_FILE) :: NCFILE
  real (c_double) :: rJulianDay
  integer (c_int) :: iIndex

  iIndex = aint(rJulianDay) - NCFILE%iFirstDayJD

end function nf_julian_day_to_index

!----------------------------------------------------------------------

function nf_index_to_dayvalue(NCFILE, iIndex)   result(rDayValue)

  type (T_NETCDF4_FILE) :: NCFILE
  integer (c_int) :: iIndex
  real (c_double) :: rDayValue

  call assert(iIndex >= lbound(NCFILE%rDateTimeValues, 1) &
    .and. iIndex <= ubound(NCFILE%rDateTimeValues, 1), &
    "Dimension out of bounds", __FILE__, __LINE__)
  rDayValue = NCFILE%rDateTimeValues(iIndex)

end function nf_index_to_dayvalue

!----------------------------------------------------------------------

function nf_dayvalue_to_julian_day(NCFILE, rDayValue)   result(rJulianDay)

  type (T_NETCDF4_FILE) :: NCFILE
  real (c_double) :: rDayValue
  real (c_double) :: rJulianDay

  rJulianDay = real(NCFILE%iOriginJD, c_double) &
    + real(NCFILE%iOriginHH, c_double) / 24_c_double &
    + real(NCFILE%iOriginMM, c_double) / 1440_c_double &
    + real(NCFILE%iOriginSS, c_double) / 86400_c_double &
    + rDayValue

end function nf_dayvalue_to_julian_day

!----------------------------------------------------------------------

function nf_julian_day_to_index_adj( NCFILE, rJulianDay )  result(iStart)

  type (T_NETCDF4_FILE ) :: NCFILE
  real (c_double) :: rJulianDay
  integer (c_size_t) :: iStart

  ! [ LOCALS ]
  integer (c_int) :: iMinDiff, iDiff
  integer (c_int) :: iCandidateIndex, iLastCandidate
  integer (c_int) :: iInitialCandidateIndex
  integer (c_int) :: iTestIndex
  real (c_double) :: rTestJD
  integer (c_int) :: iIndexLower, iIndexUpper, iIndex
  logical (c_bool) :: lChanged

  iStart = -9999
  iMinDiff = iBIGVAL
  !> First guess at what the appropriate index value should be.
  !> Current JD minus the Origin JD is a good guess.
  iCandidateIndex = nf_julian_day_to_index(NCFILE, rJulianDay)

  call assert(iCandidateIndex >=0, "Problem finding the index number of the time " &
    //"variable in netCDF file "//dquote(NCFILE%sFilename), __FILE__, __LINE__)

  iInitialCandidateIndex = iCandidateIndex

  do

    !> calculate the range of *INDEX* values to search over
    iIndexLower = max( lbound(NCFILE%rDateTimeValues, 1), iCandidateIndex - 1)
    iIndexUpper = min( ubound(NCFILE%rDateTimeValues, 1), iCandidateIndex + 1)

    lChanged = FALSE

    do iIndex=iIndexLower,iIndexUpper

      rTestJD = nf_dayvalue_to_julian_day(NCFILE=NCFILE, &
          rDayValue=NCFILE%rDateTimeValues(iIndex))

      iTestIndex = aint(rTestJD) - NCFILE%iFirstDayJD
      iDiff = abs(iTestIndex - iInitialCandidateIndex)

      if (iDiff < iMinDiff ) then

        iMinDiff = iDiff
        iCandidateIndex = iIndex
        lChanged = TRUE

      endif

    enddo

    if (.not. lChanged ) exit

  enddo

  if (iMinDiff == 0) iStart = iCandidateIndex

end function nf_julian_day_to_index_adj

!----------------------------------------------------------------------

function nf_return_VarID( NCFILE, iVarIndex)   result(iVarID)

  type (T_NETCDF4_FILE ) :: NCFILE
   integer (c_int) :: iVarIndex
   integer (c_int) :: iVarID

   type (T_NETCDF_VARIABLE), pointer :: pNC_VAR

   pNC_VAR => NCFILE%pNC_VAR(iVarIndex)

   iVarID = pNC_VAR%iNC_VarID

end function nf_return_VarID

!----------------------------------------------------------------------

function nf_return_DimID( NCFILE, iDimIndex)   result(iDimID)

  type (T_NETCDF4_FILE ) :: NCFILE
   integer (c_int) :: iDimIndex
   integer (c_int) :: iDimID

   type (T_NETCDF_DIMENSION), pointer :: pNC_DIM

   pNC_DIM => NCFILE%pNC_DIM(iDimIndex)

   iDimID = pNC_DIM%iNC_DimID

end function nf_return_DimID

!----------------------------------------------------------------------

function nf_return_VarIndex( NCFILE, iVarID)   result(iVarIndex)

  type (T_NETCDF4_FILE ) :: NCFILE
   integer (c_int) :: iVarID
   integer (c_int) :: iVarIndex

   type (T_NETCDF_VARIABLE), pointer :: pNC_VAR
   integer (c_int) :: iIndex
   logical (c_bool) :: lFound

  lFound = FALSE

  do iIndex=0, NCFILE%iNumberOfVariables - 1

    pNC_VAR => NCFILE%pNC_VAR(iIndex)

    if (pNC_VAR%iNC_VarID == iVarID) then
      lFound = TRUE
      exit
    endif

  enddo

  call assert(lFound, "INTERNAL PROGRAMMING ERROR - No matching variable " &
    //"ID found: was looking for Variable ID: "//trim(asCharacter(iVarID)), &
    __FILE__, __LINE__)

  iVarIndex = iIndex

end function nf_return_VarIndex

!----------------------------------------------------------------------

function nf_return_AttValue( NCFILE, iVarIndex, sAttName)   result(sAttValue)

  type (T_NETCDF4_FILE ) :: NCFILE
   integer (c_int) :: iVarIndex
   character (len=*) :: sAttName
   character (len=256) :: sAttValue

   type (T_NETCDF_ATTRIBUTE), dimension(:), pointer :: pNC_ATT
   integer (c_int) :: iIndex, iIndex2
   logical (c_bool) :: lFound

  if (iVarIndex < 0) then

    pNC_ATT => NCFILE%pNC_ATT

  else

    call assert(iVarIndex >= lbound(NCFILE%pNC_VAR,1) &
      .and. iVarIndex <= ubound(NCFILE%pNC_VAR,1), &
      "Index out of bounds referencing NCFILE%pNC_VAR" &
      //"~Offending index value: "//trim(asCharacter(iVarIndex)), &
      __FILE__, __LINE__)

    pNC_ATT => NCFILE%pNC_VAR(iVarIndex)%pNC_ATT

  endif

  lFound = FALSE

  do iIndex=lbound(pNC_ATT,1), ubound(pNC_ATT,1)

    if ( sAttName .strequal. pNC_ATT(iIndex)%sAttributeName ) then
      lFound = TRUE
      exit
    endif

  enddo

  call assert(lFound, "INTERNAL PROGRAMMING ERROR - No matching attribute " &
    //"name found: was looking for attribute with name: "//dquote(sAttName), &
    __FILE__, __LINE__)

  sAttValue = ""
  do iIndex2=0, ubound(pNC_ATT(iIndex)%sAttValue,1)
    sAttValue = sAttValue//" "//trim(pNC_ATT(iIndex)%sAttValue(iIndex))
  enddo


end function nf_return_AttValue

!----------------------------------------------------------------------

function nf_return_DimIndex( NCFILE, iDimID)   result(iDimIndex)

  type (T_NETCDF4_FILE ) :: NCFILE
   integer (c_int) :: iDimID
   integer (c_int) :: iDimIndex

   type (T_NETCDF_DIMENSION), pointer :: pNC_DIM
   integer (c_int) :: iIndex
   logical (c_bool) :: lFound

  lFound = FALSE

  do iIndex=0, NCFILE%iNumberOfDimensions - 1

    pNC_DIM => NCFILE%pNC_DIM(iIndex)

    if (pNC_DIM%iNC_DimID == iDimID) then
      lFound = TRUE
      exit
    endif

  enddo

  call assert(lFound, "INTERNAL PROGRAMMING ERROR - No matching dimension " &
    //"ID found: was looking for Dimension ID: "//trim(asCharacter(iDimID)), &
    __FILE__, __LINE__)

  iDimIndex = iIndex

end function nf_return_DimIndex

!----------------------------------------------------------------------

function nf_return_DimSize( NCFILE, iDimID)   result(iDimSize)

  type (T_NETCDF4_FILE ) :: NCFILE
   integer (c_int) :: iDimID
   integer (c_size_t) :: iDimSize

   type (T_NETCDF_DIMENSION), pointer :: pNC_DIM
   integer (c_int) :: iIndex
   logical (c_bool) :: lFound

  lFound = FALSE

  do iIndex=0, NCFILE%iNumberOfDimensions - 1

    pNC_DIM => NCFILE%pNC_DIM(iIndex)

    if (pNC_DIM%iNC_DimID == iDimID) then
      lFound = TRUE
      exit
    endif

  enddo

  call assert(lFound, "INTERNAL PROGRAMMING ERROR - No matching dimension " &
    //"ID found: was looking for Dimension ID: "//trim(asCharacter(iDimID)), &
    __FILE__, __LINE__)

  iDimSize = pNC_DIM%iNC_DimSize

end function nf_return_DimSize

!--------------------------------------------------------------------------------------------------

subroutine nf_guess_z_variable_name(NCFILE)

  type (T_NETCDF4_FILE ) :: NCFILE

  ! [ LOCALS ]
  integer (c_int) :: iIndex
  integer (c_int) :: iCount
  type (T_NETCDF_VARIABLE), pointer :: pNC_VAR

  do iIndex=lbound(NCFILE%pNC_VAR,1),ubound(NCFILE%pNC_VAR,1)

    pNC_VAR => NCFILE%pNC_VAR(iIndex)

    if (       ( pNC_VAR%sVariableName .strapprox. 'time')             &
         .or.  ( pNC_VAR%sVariableName .strapprox. 'x')                &
         .or.  ( pNC_VAR%sVariableName .strapprox. 'y')                &
         .or.  ( pNC_VAR%sVariableName .strapprox. 'time_bnds')        &
         .or.  ( pNC_VAR%sVariableName .strapprox. 'lat')              &
         .or.  ( pNC_VAR%sVariableName .strapprox. 'lon') )  cycle

    NCFILE%sVarName(NC_Z) = pNC_VAR%sVariableName
    exit

  enddo

end subroutine nf_guess_z_variable_name

!--------------------------------------------------------------------------------------------------

subroutine netcdf_open_and_prepare_for_merging( NCFILE, sFilename, guess_z_var_name )

  type (T_NETCDF4_FILE ), intent(inout)       :: NCFILE
  character (len=*), intent(in)               :: sFilename
  logical (c_bool), intent(in), optional :: guess_z_var_name

  ! [ LOCALS ]
  type (T_NETCDF_VARIABLE), pointer :: pNC_VAR
  type (T_NETCDF_DIMENSION), pointer :: pNC_DIM
  logical (c_bool) :: lFileOpen
  integer (c_int), dimension(2) :: iColRow_ll, iColRow_ur, iColRow_lr, iColRow_ul
  integer (c_int) :: iColmin, iColmax, iRowmin, iRowmax
  integer (c_int) :: iIndex
  logical (c_bool) :: guess_z_var_name_l

  if (present( guess_z_var_name) ) then
    guess_z_var_name_l = guess_z_var_name
  else
    guess_z_var_name_l = FALSE
  endif

  call nf_open_file(NCFILE=NCFILE, sFilename=sFilename)

  call nf_populate_dimension_struct( NCFILE )

  call nf_populate_variable_struct( NCFILE )

  if (guess_z_var_name_l)  call nf_guess_z_variable_name(NCFILE)

  call nf_get_variable_id_and_type( NCFILE, strict_asserts=TRUE )

  ! OK. We only want to attempt to call functions that
  ! process the time variable if a time variable actually exists!!
  if ( NCFILE%iVarID(NC_TIME) >= 0 ) then

    NCFILE%dpFirstAndLastTimeValues = nf_get_first_and_last(NCFILE=NCFILE, &
        iVarIndex=NCFILE%iVarIndex(NC_TIME) )

    !> look for and process the "days since MM-DD-YYYY" attribute
    call nf_get_time_units(NCFILE=NCFILE)

    call nf_calculate_time_range(NCFILE)

    !> retrieve the time values as included in the netCDF file
    call nf_get_time_vals(NCFILE)

  endif

  !> retrieve the X and Y coordinates from the netCDF file...
  call nf_get_x_and_y(NCFILE)

  !> define the entire grid area as the AOI
  NCFILE%iColBounds(NC_LEFT) = lbound(NCFILE%rX_Coords,1)
  NCFILE%iColBounds(NC_RIGHT) = ubound(NCFILE%rX_Coords,1)

  NCFILE%iRowBounds(NC_TOP) = lbound(NCFILE%rY_Coords,1)
  NCFILE%iRowBounds(NC_BOTTOM) = ubound(NCFILE%rY_Coords,1)

  !> based on the subset of the netCDF file as determined above, set the
  !> start, count, and stride parameters for use in all further data
  !> retrievals
  call nf_set_start_count_stride(NCFILE)

  !> establish the bounds to iterate over; this can enable horiz or vert flipping
  call nf_set_iteration_bounds(NCFILE)

  !> now that we have (possibly) created a subset, need to get the
  !> **NATIVE** coordinate bounds so that the intermediate grid file
  !> can be created
  call nf_return_native_coord_bounds(NCFILE)

end subroutine netcdf_open_and_prepare_for_merging

!----------------------------------------------------------------------

subroutine netcdf_open_and_prepare_as_input(NCFILE, sFilename, &
    lFlipHorizontal, lFlipVertical,                            &
    lAllowAutomaticDataFlipping,                               &
    rX_Coord_AddOffset, rY_Coord_AddOffset,                    &
    sVariableOrder, sVarName_x,                                &
    sVarName_y, sVarName_z, sVarName_time,                     &
    rCoordinateTolerance,                                      &
    tGridBounds, iLU)

  type (T_NETCDF4_FILE ) :: NCFILE
  character (len=*) :: sFilename
  logical (c_bool), optional :: lFlipHorizontal
  logical (c_bool), optional :: lFlipVertical
  logical (c_bool), optional :: lAllowAutomaticDataFlipping
  character (len=*), optional :: sVariableOrder
  real (c_double), optional    :: rX_Coord_AddOffset
  real (c_double), optional    :: rY_Coord_AddOffset
  character (len=*), optional :: sVarName_x
  character (len=*), optional :: sVarName_y
  character (len=*), optional :: sVarName_z
  character (len=*), optional :: sVarName_time
  real (c_double), optional   :: rCoordinateTolerance
  type (GRID_BOUNDS_T), optional :: tGridBounds
  integer (c_int), optional :: iLU

  ! [ LOCALS ]
  type (T_NETCDF_VARIABLE), pointer :: pNC_VAR
  type (T_NETCDF_DIMENSION), pointer :: pNC_DIM
  logical (c_bool) :: lFileOpen
  integer (c_int), dimension(2) :: iColRow_ll, iColRow_ur, iColRow_lr, iColRow_ul
  integer (c_int) :: iColmin, iColmax, iRowmin, iRowmax
  integer (c_int) :: iIndex

  call nf_open_file(NCFILE=NCFILE, sFilename=sFilename)

  call nf_populate_dimension_struct( NCFILE )
  call nf_populate_variable_struct( NCFILE )

  if (present(lFlipHorizontal) ) NCFILE%lFlipHorizontal = lFlipHorizontal
  if (present(lFlipVertical) ) NCFILE%lFlipVertical = lFlipVertical
  if (present( lAllowAutomaticDataFlipping) )                                 &
      NCFILE%lAllowAutomaticDataFlipping = lAllowAutomaticDataFlipping
  if (present(rX_Coord_AddOffset))  NCFILE%rX_Coord_AddOffset = rX_Coord_AddOffset
  if (present(rY_Coord_AddOffset))  NCFILE%rY_Coord_AddOffset = rY_Coord_AddOffset

  if (present(rCoordinateTolerance))  NCFILE%rCoordinateTolerance = rCoordinateTolerance

  if (present(sVariableOrder) )  NCFILE%sVariableOrder = sVariableOrder

  if( present(iLU) ) then
    inquire (unit=iLU, opened=lFileOpen)
    if ( lFileOpen )  call netcdf_dump_cdl( NCFILE, iLU)
  endif

  if (present(sVarName_x) ) then
    NCFILE%sVarName(NC_X) = sVarName_x
  else
    NCFILE%sVarName(NC_X) = "x"
  endif

  if (present(sVarName_y) ) then
    NCFILE%sVarName(NC_Y) = sVarName_y
  else
    NCFILE%sVarName(NC_Y) = "y"
  endif

  if (present(sVarName_z) ) then
    NCFILE%sVarName(NC_Z) = sVarName_z
  else
    NCFILE%sVarName(NC_Z) = "prcp"
  endif

  if (present(sVarName_time) ) then
    NCFILE%sVarName(NC_TIME) = sVarName_time
  else
    NCFILE%sVarName(NC_TIME) = "time"
  endif

  call nf_get_variable_id_and_type( NCFILE )

  ! OK. We only want to attempt to call functions that
  ! process the time variable if a time variable actually exists!!
  if ( NCFILE%iVarID(NC_TIME) >= 0 ) then

    NCFILE%dpFirstAndLastTimeValues = nf_get_first_and_last(NCFILE=NCFILE, &
        iVarIndex=NCFILE%iVarIndex(NC_TIME) )
   
    !> look for and process the "days since MM-D-YYYY" attribute
    call nf_get_time_units(NCFILE=NCFILE)

    call nf_calculate_time_range(NCFILE)

    !> retrieve the time values as included in the netCDF file
    call nf_get_time_vals(NCFILE)

  endif

  call nf_get_xyz_units(NCFILE=NCFILE)

  !> establish scale_factor and add_offset values, if present
  call nf_get_scale_and_offset(NCFILE=NCFILE)

  !> retrieve the X and Y coordinates from the netCDF file...
  call nf_get_x_and_y(NCFILE)

  if (present(tGridBounds) ) then

    !> define a subset of the grid as the AOI
    !> need all four corner points since it is likely that
    !> the AOI rectangle is rotated relative to the base
    !> projection

    iColRow_ll = netcdf_coord_to_col_row(NCFILE=NCFILE, &
                                     rX=tGridBounds%rXll, &
                                     rY=tGridBounds%rYll)
  
    iColRow_lr = netcdf_coord_to_col_row(NCFILE=NCFILE, &
                                     rX=tGridBounds%rXlr, &
                                     rY=tGridBounds%rYlr)

    iColRow_ul = netcdf_coord_to_col_row(NCFILE=NCFILE, &
                                     rX=tGridBounds%rXul, &
                                     rY=tGridBounds%rYul)

    iColRow_ur = netcdf_coord_to_col_row(NCFILE=NCFILE, &
                                     rX=tGridBounds%rXur, &
                                     rY=tGridBounds%rYur)

#ifdef DEBUG_PRINT
    write(*, fmt="(a)") "subroutine 'netcdf_open_and_prepare_as_input'"
    write(*, fmt="(a,a,i6)") "Find correspondence between project bounds (in native projection) and row, col of dataset | ", &
      trim(__FILE__), __LINE__
    write(*, fmt="(a)") "      column     row              X              Y"
    write(*, fmt="(a,i6,i6,a,f14.3,f14.3)") "LL: ", iColRow_ll(COLUMN), iColRow_ll(ROW), " <==> ", tGridBounds%rXll, tGridBounds%rYll
    write(*, fmt="(a,i6,i6,a,f14.3,f14.3)") "LR: ", iColRow_lr(COLUMN), iColRow_lr(ROW), " <==> ", tGridBounds%rXlr, tGridBounds%rYlr
    write(*, fmt="(a,i6,i6,a,f14.3,f14.3)") "UL: ", iColRow_ul(COLUMN), iColRow_ul(ROW), " <==> ", tGridBounds%rXul, tGridBounds%rYul
    write(*, fmt="(a,i6,i6,a,f14.3,f14.3)") "UR: ", iColRow_ur(COLUMN), iColRow_ur(ROW), " <==> ", tGridBounds%rXur, tGridBounds%rYur
#endif

    NCFILE%iColBounds(NC_LEFT) = &
      max( min( iColRow_ul(COLUMN), iColRow_ur(COLUMN), iColRow_ll(COLUMN), iColRow_lr(COLUMN) ) - 4, &
                lbound(NCFILE%rX_Coords,1) )

    NCFILE%iColBounds(NC_RIGHT) = &
      min( max( iColRow_ul(COLUMN), iColRow_ur(COLUMN), iColRow_ll(COLUMN), iColRow_lr(COLUMN) ) + 4, &
                ubound(NCFILE%rX_Coords,1) )


      NCFILE%iRowBounds(NC_TOP) = &
        max( min( iColRow_ul(ROW), iColRow_ur(ROW), iColRow_ll(ROW), iColRow_lr(ROW) ) - 4, &
                  lbound(NCFILE%rY_Coords,1) )

      NCFILE%iRowBounds(NC_BOTTOM) = &
        min( max( iColRow_ul(ROW), iColRow_ur(ROW), iColRow_ll(ROW), iColRow_lr(ROW) ) + 4, &
                  ubound(NCFILE%rY_Coords,1) )

  else

    !> define the entire grid area as the AOI
    NCFILE%iColBounds(NC_LEFT) = lbound(NCFILE%rX_Coords,1)
    NCFILE%iColBounds(NC_RIGHT) = ubound(NCFILE%rX_Coords,1)

    NCFILE%iRowBounds(NC_TOP) = lbound(NCFILE%rY_Coords,1)
    NCFILE%iRowBounds(NC_BOTTOM) = ubound(NCFILE%rY_Coords,1)

  endif

  !> based on the subset of the netCDF file as determined above, set the
  !> start, count, and stride parameters for use in all further data
  !> retrievals
  call nf_set_start_count_stride(NCFILE)

  !> establish the bounds to iterate over; this can enable horiz or vert flipping
  call nf_set_iteration_bounds(NCFILE)

  !> now that we have (possibly) created a subset, need to get the
  !> **NATIVE** coordinate bounds so that the intermediate grid file
  !> can be created
  call nf_return_native_coord_bounds(NCFILE)

end subroutine netcdf_open_and_prepare_as_input

!----------------------------------------------------------------------

subroutine netcdf_open_and_prepare_as_output_archive(NCFILE, NCFILE_ARCHIVE, &
   iOriginMonth, iOriginDay, iOriginYear, iStartYear, iEndYear)

  type (T_NETCDF4_FILE ) :: NCFILE
  type (T_NETCDF4_FILE ) :: NCFILE_ARCHIVE
  integer (c_int) :: iOriginMonth
  integer (c_int) :: iOriginDay
  integer (c_int) :: iOriginYear
  integer (c_int) :: iStartYear
  integer (c_int) :: iEndYear

  ! [ LOCALS ]
  type (T_NETCDF_VARIABLE), pointer :: pNC_VAR
  type (T_NETCDF_DIMENSION), pointer :: pNC_DIM
  integer (c_int) :: iIndex
  integer (c_int) :: iNumCols, iNumRows
  integer (c_int) :: iMinCol, iMaxCol
  integer (c_int) :: iMinRow, iMaxRow
  real (c_double), dimension(:), allocatable :: rX, rY
  character (len=10) :: sOriginText
  character (len=256) :: sFilename

  write(sOriginText, fmt="(i4.4,'-',i2.2,'-',i2.2)") iOriginYear, &
    iOriginMonth, iOriginDay

  iMaxRow = maxval(NCFILE%iRowBounds)
  iMinRow = minval(NCFILE%iRowBounds)
  iMaxCol = maxval(NCFILE%iColBounds)
  iMinCol = minval(NCFILE%iColBounds)

  iNumRows = iMaxRow - iMinRow + 1
  iNumCols = iMaxCol - iMinCol + 1

  allocate(rX(iNumCols))
  allocate(rY(iNumRows))
  rX = NCFILE%rX_Coords(iMinCol:iMaxCol)
  rY = NCFILE%rY_Coords(iMinRow:iMaxRow)

  sFilename = trim(NCFILE%sVarName(NC_Z))//"_"//trim(asCharacter(iStartYear)) &
    //"_"//trim(asCharacter(iEndYear))//"__" &
    //trim(asCharacter(iNumRows)) &
     //"_by_"//trim(asCharacter(iNumCols))//".nc"

  call nf_create(NCFILE=NCFILE_ARCHIVE, sFilename=trim(sFilename) )

  !> set dimension values in the NCFILE struct
  call nf_set_standard_dimensions(NCFILE=NCFILE_ARCHIVE, &
                       iNX=iNumCols, &
                       iNY=iNumRows)

  NCFILE_ARCHIVE%sVarUnits(NC_X) =   NCFILE%sVarUnits(NC_X)
  NCFILE_ARCHIVE%sVarUnits(NC_Y) =   NCFILE%sVarUnits(NC_Y)
  NCFILE_ARCHIVE%sVarUnits(NC_Z) =   NCFILE%sVarUnits(NC_Z)

  !> transfer dimension values to netCDF file
  call nf_define_dimensions( NCFILE=NCFILE_ARCHIVE )

  !> set variable values in the NCFILE struct
  call nf_set_standard_variables(NCFILE=NCFILE_ARCHIVE, &
       sVarName_z = trim(NCFILE%sVarName(NC_Z)) )

  !> transfer variable values to netCDF file
  call nf_define_variables(NCFILE=NCFILE_ARCHIVE)

  call nf_get_variable_id_and_type( NCFILE=NCFILE_ARCHIVE )

  call nf_set_standard_attributes(NCFILE=NCFILE_ARCHIVE, &
    sOriginText=sOriginText)

  call nf_set_global_attributes(NCFILE=NCFILE_ARCHIVE, &
     sDataType=trim(NCFILE%sVarName(NC_Z)), &
     sSourceFile=trim(NCFILE%sFilename))

  call nf_put_attributes(NCFILE=NCFILE_ARCHIVE)

  !> enable a low level of data compression for the
  !> variable of interest
  call nf_define_deflate(NCFILE=NCFILE_ARCHIVE, &
     iVarID=NCFILE_ARCHIVE%iVarID(NC_Z), &
     iShuffle=NC_SHUFFLE_YES, &
     iDeflate=NC_DEFLATE_YES, &
     iDeflate_level=2 )

  call nf_enddef(NCFILE=NCFILE_ARCHIVE)

  call nf_put_x_and_y(NCFILE=NCFILE_ARCHIVE, &
       dpX=NCFILE%rX_Coords(iMinCol:iMaxCol), &
       dpY=NCFILE%rY_Coords(iMinRow:iMaxRow) )
!       dpX=rX, &
!       dpY=rY )

!  call netcdf_close_file(NCFILE_ARCHIVE)

end subroutine netcdf_open_and_prepare_as_output_archive



subroutine netcdf_open_and_prepare_as_output( NCFILE, sVariableName, sVariableUnits,    &
   iNX, iNY, fX, fY, StartDate, EndDate, PROJ4_string, history_list, executable_name,   &
   dpLat, dpLon, fValidMin, fValidMax, write_time_bounds, filename_prefix,              &
   filename_modifier)

  type (T_NETCDF4_FILE ), pointer, intent(inout)       :: NCFILE
  character (len=*), intent(in)                        :: sVariableName
  character (len=*), intent(in)                        :: sVariableUnits
  integer (c_int), intent(in)                          :: iNY
  real (c_double), intent(in)                          :: fX(:)
  integer (c_int), intent(in)                          :: iNX
  real (c_double), intent(in)                          :: fY(:)
  type (DATETIME_T), intent(in)                        :: StartDate
  type (DATETIME_T), intent(in)                        :: EndDate
  character (len=*), intent(in)                        :: PROJ4_string
  type (FSTRING_LIST_T), intent(in), pointer, optional :: history_list
  character (len=*), intent(in), optional              :: executable_name
  real (c_double), intent(in), optional                :: dpLat(:,:)
  real (c_double), intent(in), optional                :: dpLon(:,:)
  real (c_float), intent(in), optional                 :: fValidMin
  real (c_float), intent(in), optional                 :: fValidMax
  logical (c_bool), intent(in), optional               :: write_time_bounds
  character (len=*), intent(in), optional              :: filename_prefix
  character (len=*), intent(in), optional              :: filename_modifier

!   ! [ LOCALS ]
  type (T_NETCDF_VARIABLE), pointer :: pNC_VAR
  type (T_NETCDF_DIMENSION), pointer :: pNC_DIM
  integer (c_int) :: iIndex
  character (len=10)                                :: sOriginText
  character (len=:), allocatable                    :: sFilename
  type (FSTRING_LIST_T), pointer                    :: history_list_l
  logical (c_bool)                                  :: write_time_bounds_l
  character (len=:), allocatable                    :: executable_name_l
  real (c_float)                                    :: valid_minimum
  real (c_float)                                    :: valid_maximum
  logical (c_bool)                                  :: include_latlon
  type (DATETIME_T)                                 :: DT
  character (len=:), allocatable                    :: date_time_text
  character (len=:), allocatable                    :: filename_prefix_l
  character (len=:), allocatable                    :: filename_modifier_l
  call DT%systime()
  date_time_text = DT%prettydatetime()


  if (present( fValidMin ) ) then
    valid_minimum = fValidMin
  else
    valid_minimum = -1.0E+3
  endif

  if (present( fValidMax ) ) then
    valid_maximum = fValidMax
  else
    valid_maximum = 1.0E+10
  endif

  if ( present( executable_name ) ) then
    executable_name_l = trim( executable_name )
  else
    executable_name_l = "SWB"
  endif

  if ( present( filename_modifier ) ) then
    filename_modifier_l = "_"//trim( filename_modifier )//"_"
  else
    filename_modifier_l = "_"
  endif

  if ( present( filename_prefix ) ) then
    if (len_trim(filename_prefix) > 0) then
      filename_prefix_l = trim( filename_prefix )//"_"
    else 
      filename_prefix_l = ""
    endif
  else
    filename_prefix_l = ""
  endif

  if ( present( history_list) ) then
    history_list_l => history_list
  else
    allocate( history_list_l )
    call history_list_l%append(date_time_text//": Soil-Water-Balance run started.")
  endif

  if ( present( write_time_bounds ) ) then
    write_time_bounds_l = write_time_bounds
  else
    write_time_bounds_l = FALSE
  endif

  include_latlon = logical( present( dpLat ) .and. present( dpLon ), c_bool )

  write(sOriginText, fmt="(i4.4,'-',i2.2,'-',i2.2)") StartDate%iYear, StartDate%iMonth, StartDate%iDay

  ! if a filename_prefix argument has been supplied, override the variable specified in
  ! the 'output' module
  if (len_trim(filename_prefix_l) > 0 ) then

  sFilename = trim(OUTPUT_DIRECTORY_NAME)//trim(filename_prefix_l)              &
    //trim(sVariableName)//"_"//filename_modifier_l                             &
    //StartDate%prettydate()//"_to_"//EndDate%prettydate()//"__"                &
    //trim(asCharacter(iNY))//"_by_"//trim(asCharacter(iNX))//".nc"

  else

    sFilename = trim(OUTPUT_DIRECTORY_NAME)//trim(OUTPUT_PREFIX_NAME)           &
    //trim(sVariableName)//"_"//filename_modifier_l                             &
    //StartDate%prettydate()//"_to_"//EndDate%prettydate()//"__"                &
    //trim(asCharacter(iNY))//"_by_"//trim(asCharacter(iNX))//".nc"

  endif

  call LOGS%write("Attempting to open netCDF file for writing with filename "//dquote(sFilename))

  call nf_create(NCFILE=NCFILE, sFilename=trim(sFilename) )

  !> set dimension values in the NCFILE struct
  call nf_set_standard_dimensions(NCFILE=NCFILE, iNX=iNX, iNY=iNY,            &
                                  write_time_bounds=write_time_bounds_l )

  !> @todo implement more flexible method of assigning units
!   NCFILE%sVarUnits(NC_X)    = sXY_units
!   NCFILE%sVarUnits(NC_Y)    = sXY_units
  NCFILE%sVarUnits(NC_Z)    = sVariableUnits

  !> transfer dimension values to netCDF file
  call nf_define_dimensions( NCFILE=NCFILE )

  !> set variable values in the NCFILE struct
  call nf_set_standard_variables(NCFILE=NCFILE, sVarName_z = sVariableName,   &
    lLatLon=include_latlon, write_time_bounds=write_time_bounds_l )

  !> transfer variable values to netCDF file
  call nf_define_variables(NCFILE=NCFILE)

  call nf_get_variable_id_and_type( NCFILE=NCFILE )

  call nf_set_standard_attributes(NCFILE=NCFILE, sOriginText=sOriginText,     &
      PROJ4_string=PROJ4_string, lLatLon=include_latlon, fValidMin=valid_minimum, &
      fValidMax=valid_maximum, write_time_bounds=write_time_bounds_l )

  call nf_set_global_attributes(NCFILE=NCFILE, &
     sDataType=trim(NCFILE%sVarName(NC_Z)), history_list=history_list_l, &
     executable_name=executable_name_l )

  call nf_put_attributes(NCFILE=NCFILE)

  !> enable a low level of data compression for the variable of interest
   call nf_define_deflate(NCFILE=NCFILE, &
      iVarID=NCFILE%iVarID(NC_Z), &
      iShuffle=NC_SHUFFLE_YES, &
      iDeflate=NC_DEFLATE_YES, &
      iDeflate_level=2 )

  call nf_enddef(NCFILE=NCFILE)

  ! we are only supplying a vector of X and Y on the assumption that the base projection
  ! results in a uniform grid (in other words, we have the same X value for all coluns of a given row)
  call nf_put_x_and_y(NCFILE=NCFILE, &
       dpX=fX, &
       dpY=fY )

!  allocate( NCFILE%rX_Coords( size( fX) ), stat=iStat )
!  allocate( NCFILE%rY_Coords( size( fY) ), stat=iStat )
  NCFILE%rX_Coords = fX
  NCFILE%rY_Coords = fY

  if (present( dpLat ) .and. present( dpLon ) ) then

    call nf_put_lat_and_lon(NCFILE=NCFILE, &
       dpLat=dpLat, &
       dpLon=dpLon )

  endif

end subroutine netcdf_open_and_prepare_as_output


!----------------------------------------------------------------------

subroutine nf_set_z_variable_name(NCFILE, sVarName_z)

  type (T_NETCDF4_FILE ) :: NCFILE
  character (len=*) :: sVarName_z

  NCFILE%sVarName(NC_Z) = sVarName_z

end subroutine nf_set_z_variable_name

!----------------------------------------------------------------------

subroutine nf_set_iteration_bounds(NCFILE)

  type (T_NETCDF4_FILE ) :: NCFILE

!  if (NCFILE%lFlipVertical) then
!    NCFILE%iRowIter(NC_FIRST) = NCFILE%iNY
!    NCFILE%iRowIter(NC_LAST) = 1
!    NCFILE%iRowIter(NC_BY) = -1
! else
    NCFILE%iRowIter(NC_FIRST) = 1
    NCFILE%iRowIter(NC_LAST) = NCFILE%iNY
    NCFILE%iRowIter(NC_BY) = 1
!  endif

  ! if (NCFILE%lFlipHorizontal) then
  !   NCFILE%iColIter(NC_FIRST) = NCFILE%iNX
  !   NCFILE%iColIter(NC_LAST) = 1
  !   NCFILE%iColIter(NC_BY) = -1
  ! else
    NCFILE%iColIter(NC_FIRST) = 1
    NCFILE%iColIter(NC_LAST) = NCFILE%iNX
    NCFILE%iColIter(NC_BY) = 1
  ! endif

end subroutine nf_set_iteration_bounds

!----------------------------------------------------------------------

subroutine nf_set_start_count_stride(NCFILE)

  type (T_NETCDF4_FILE ) :: NCFILE

  ! [ LOCALS ]
  integer (c_int) :: iIndex

  ! loop over the three (assumed) dimensions of the "Z" variable;
  ! assign appropriate bounds to each
  do iIndex = 0,3

    select case (iIndex)

      case (NC_X)

        !> need to subtract 1 from the start index: we are using the
        !> netCDF C API, in which index values are relative to zero
        NCFILE%iStart(iIndex) = minval(NCFILE%iColBounds) - 1
        NCFILE%iNX = maxval(NCFILE%iColBounds) - minval(NCFILE%iColBounds) + 1
        NCFILE%iCount(iIndex) = NCFILE%iNX
!        NCFILE%iCount(iIndex) = maxval(NCFILE%iColBounds) - minval(NCFILE%iColBounds)
        NCFILE%iStride(iIndex) = 1_c_size_t

      case (NC_Y)

        !> note: this assumes that the row numbers increase from top to bottom,
        !>       while the Y coordinates decrease top to bottom

        NCFILE%iStart(iIndex) = minval(NCFILE%iRowBounds) - 1
        NCFILE%iNY = maxval(NCFILE%iRowBounds) - minval(NCFILE%iRowBounds) + 1
        NCFILE%iCount(iIndex) = NCFILE%iNY
        !>
        !> count must be set to the number of values! maxval minus minval results
        !> in a diagonal pattern in the input as we read in the incorrect number
        !> of results
!        NCFILE%iCount(iIndex) = maxval(NCFILE%iRowBounds) - minval(NCFILE%iRowBounds)
        NCFILE%iStride(iIndex) = 1_c_size_t

      case (NC_TIME)

        NCFILE%iStart(iIndex) = 0_c_size_t
        NCFILE%iCount(iIndex) = 1_c_size_t
        NCFILE%iStride(iIndex) = 1_c_size_t

      case default

    end select

  enddo

end subroutine nf_set_start_count_stride

!----------------------------------------------------------------------

subroutine nf_return_native_coord_bounds(NCFILE)

  type (T_NETCDF4_FILE ) :: NCFILE

  ! [ LOCALS ]
  real (c_double) :: rXmin, rXmax
  real (c_double) :: rYmin, rYmax

  !> find the (x,y) associated with the column and row number bounds
  rXmin = minval(NCFILE%rX_Coords(NCFILE%iColBounds(NC_LEFT):NCFILE%iColBounds(NC_RIGHT)) )
  rXmax = maxval(NCFILE%rX_Coords(NCFILE%iColBounds(NC_LEFT):NCFILE%iColBounds(NC_RIGHT)) )
  rYmin = minval(NCFILE%rY_Coords(NCFILE%iRowBounds(NC_TOP):NCFILE%iRowBounds(NC_BOTTOM)) )
  rYmax = maxval(NCFILE%rY_Coords(NCFILE%iRowBounds(NC_TOP):NCFILE%iRowBounds(NC_BOTTOM)) )

  NCFILE%rX(NC_LEFT) = rXmin - NCFILE%rGridCellSizeX * 0.5_c_double
  NCFILE%rX(NC_RIGHT) = rXmax + NCFILE%rGridCellSizeX * 0.5_c_double
  NCFILE%rY(NC_TOP) = rYmax + NCFILE%rGridCellSizeY * 0.5_c_double
  NCFILE%rY(NC_BOTTOM) = rYmin - NCFILE%rGridCellSizeY * 0.5_c_double

#ifdef DEBUG_PRINT
  print *, ""
  print *, repeat("-", 80)
  print *, "Filename: ", NCFILE%sFilename
  print *, "Grid cell size (X): ", NCFILE%rGridCellSizeX
  print *, "Grid cell size (Y): ", NCFILE%rGridCellSizeY

  print *, "Bounds of data subset area, in native coordinates"
  print *, "X (left): ", NCFILE%rX(NC_LEFT)
  print *, "X (right): ", NCFILE%rX(NC_RIGHT)
  print *, "Y (top): ", NCFILE%rY(NC_TOP)
  print *, "Y (bottom): ", NCFILE%rY(NC_BOTTOM)
  print *, ""
#endif

end subroutine nf_return_native_coord_bounds

!----------------------------------------------------------------------

subroutine nf_get_time_vals(NCFILE)

  type (T_NETCDF4_FILE ) :: NCFILE

  integer (c_int) :: iVarIndex_time
  type (T_NETCDF_VARIABLE), pointer :: pNC_VAR_time
  type (T_NETCDF_DIMENSION), pointer :: pNC_DIM_time
  integer (c_int) :: iLowerBound, iUpperBound
  integer (c_int) :: iStat

  iStat = 0

  iVarIndex_time = NCFILE%iVarIndex(NC_TIME)

  call assert(iVarIndex_time >= lbound(NCFILE%pNC_VAR,1) &
    .and. iVarIndex_time <= ubound(NCFILE%pNC_VAR,1), &
    "INTERNAL PROGRAMMING ERROR - Index out of bounds", __FILE__, __LINE__)

  pNC_VAR_time => NCFILE%pNC_VAR(iVarIndex_time)
  pNC_DIM_time => NCFILE%pNC_DIM( pNC_VAR_time%iNC_DimID(0) )

  if (allocated(NCFILE%rDateTimeValues) ) deallocate(NCFILE%rDateTimeValues, stat=iStat)
  call assert(iStat==0, "Failed to deallocate memory for time values", &
    __FILE__, __LINE__)

  allocate( NCFILE%rDateTimeValues(0 : pNC_DIM_time%iNC_DimSize-1 ), stat=iStat )
  call assert(iStat==0, "Failed to allocate memory for time values", &
    __FILE__, __LINE__)

  !> @todo allow time to be read in as float, short, or int as well

  call nf_get_variable_vector_double(NCFILE=NCFILE, &
       iNC_VarID=pNC_VAR_time%iNC_VarID, &
       iNC_Start=0_c_size_t, &
       iNC_Count=pNC_DIM_time%iNC_DimSize, &
       iNC_Stride=1_c_size_t, &
       dpNC_Vars=NCFILE%rDateTimeValues)

end subroutine nf_get_time_vals

!----------------------------------------------------------------------

subroutine nf_get_x_and_y(NCFILE)

  type (T_NETCDF4_FILE ) :: NCFILE

  integer (c_int) :: iVarIndex_x, iVarIndex_y
  type (T_NETCDF_VARIABLE), pointer :: pNC_VAR_x, pNC_VAR_y
  type (T_NETCDF_DIMENSION), pointer :: pNC_DIM_x, pNC_DIM_y
  integer (c_int) :: iLowerBound, iUpperBound
  integer (c_int) :: iStat

  iVarIndex_x = NCFILE%iVarIndex(NC_X)
  iVarIndex_y = NCFILE%iVarIndex(NC_Y)

  call assert(iVarIndex_x >= lbound(NCFILE%pNC_VAR,1) &
    .and. iVarIndex_x <= ubound(NCFILE%pNC_VAR,1), &
    "INTERNAL PROGRAMMING ERROR - Index out of bounds", __FILE__, __LINE__)

  call assert(iVarIndex_y >= lbound(NCFILE%pNC_VAR,1) &
    .and. iVarIndex_y <= ubound(NCFILE%pNC_VAR,1), &
    "INTERNAL PROGRAMMING ERROR - Index out of bounds", __FILE__, __LINE__)

  pNC_VAR_x => NCFILE%pNC_VAR(iVarIndex_x)
  pNC_VAR_y => NCFILE%pNC_VAR(iVarIndex_y)

  call assert( pNC_VAR_x%iNumberOfDimensions == 1, &
    "Dimensions other than one for the x-coordinate variable are currently unsupported.", &
    __FILE__, __LINE__)

  call assert( pNC_VAR_y%iNumberOfDimensions == 1, &
    "Dimensions other than one for the y-coordinate variable are currently unsupported.", &
    __FILE__, __LINE__)

  pNC_DIM_x => NCFILE%pNC_DIM( pNC_VAR_x%iNC_DimID(0) )
  pNC_DIM_y => NCFILE%pNC_DIM( pNC_VAR_y%iNC_DimID(0) )

  allocate( NCFILE%rX_Coords( pNC_DIM_x%iNC_DimSize ), stat=iStat )
  call assert(iStat==0, "Failed to allocate memory for X-coordinate values", &
    __FILE__, __LINE__)

  allocate (NCFILE%rY_Coords( pNC_DIM_y%iNC_DimSize  ), stat=iStat )
  call assert(iStat==0, "Failed to allocate memory for Y-coordinate values", &
    __FILE__, __LINE__)

  call nf_get_variable_vector_double(NCFILE=NCFILE, &
       iNC_VarID=pNC_VAR_x%iNC_VarID, &
       iNC_Start=0_c_size_t, &
       iNC_Count=pNC_DIM_x%iNC_DimSize, &
       iNC_Stride=1_c_size_t, &
       dpNC_Vars=NCFILE%rX_Coords)

  call nf_get_variable_vector_double(NCFILE=NCFILE, &
       iNC_VarID=pNC_VAR_y%iNC_VarID, &
       iNC_Start=0_c_size_t, &
       iNC_Count=pNC_DIM_y%iNC_DimSize, &
       iNC_Stride=1_c_size_t, &
       dpNC_Vars=NCFILE%rY_Coords)

  NCFILE%rX_Coords = NCFILE%rX_Coords + NCFILE%rX_Coord_AddOffset
  NCFILE%rY_Coords = NCFILE%rY_Coords + NCFILE%rY_Coord_AddOffset

  iLowerBound = lbound(NCFILE%rX_Coords, 1)
  iUpperBound = ubound(NCFILE%rX_Coords, 1)

  if (NCFILE%rX_Coords(iUpperBound) > NCFILE%rX_Coords(iLowerBound) ) then
    NCFILE%lX_IncreasesWithIndex = TRUE
    if ( NCFILE%lAllowAutomaticDataFlipping ) NCFILE%lFlipHorizontal = FALSE
  else
    NCFILE%lX_IncreasesWithIndex = FALSE
    if ( NCFILE%lAllowAutomaticDataFlipping ) then
      NCFILE%lFlipHorizontal       = TRUE
      call LOGS%write( "** Horizontal coordinates decrease with index values **", &
                       iLinesBefore=1,                                            &
                       iLogLevel=LOG_ALL )
      call LOGS%write( "  ==> flipping grid horizontally",                        &
                       iLinesAfter=1,                                             &
                       iLogLevel=LOG_ALL )
    endif
  endif

  iLowerBound = lbound(NCFILE%rY_Coords, 1)
  iUpperBound = ubound(NCFILE%rY_Coords, 1)

  if (NCFILE%rY_Coords(iUpperBound) > NCFILE%rY_Coords(iLowerBound) ) then
    NCFILE%lY_IncreasesWithIndex = TRUE
    if ( NCFILE%lAllowAutomaticDataFlipping ) then
      NCFILE%lFlipVertical         = TRUE
      call LOGS%write( "** Vertical coordinates increase with index values **", &
                       iLinesBefore=1,                                          &
                       iLogLevel=LOG_ALL )
      call LOGS%write( "  ==> flipping grid vertically",                        &
                       iLinesAfter=1,                                           &
                       iLogLevel=LOG_ALL )
    endif
  else
    NCFILE%lY_IncreasesWithIndex = FALSE
    if ( NCFILE%lAllowAutomaticDataFlipping ) NCFILE%lFlipVertical = FALSE
  endif

  call assert(pNC_DIM_x%iNC_DimSize > 2, "INTERNAL PROGRAMMING ERROR - " &
    //"netCDF X dimension size must be greater than 2.", __FILE__, __LINE__)

  call assert(pNC_DIM_y%iNC_DimSize > 2, "INTERNAL PROGRAMMING ERROR - " &
    //"netCDF Y dimension size must be greater than 2.", __FILE__, __LINE__)

  NCFILE%rGridCellSizeX = ( maxval(NCFILE%rX_Coords) &
                                - minval(NCFILE%rX_Coords) ) &
                                / real (pNC_DIM_x%iNC_DimSize - 1, c_double)

  NCFILE%rGridCellSizeY = ( maxval(NCFILE%rY_Coords) &
                                - minval(NCFILE%rY_Coords) ) &
                                / real (pNC_DIM_y%iNC_DimSize - 1, c_double)

  ! print *, '*** netCDF x- and y- coord read ***'
  ! print *, trim(__FILE__), ': ', __LINE__
  ! print *, 'file:', trim(NCFILE%sFilename)
  ! print *, 'x-coords: ', NCFILE%rX_Coords
  ! print *, 'y-coords: ', NCFILE%rY_Coords
  ! print *, '***********************************'

end subroutine nf_get_x_and_y

!----------------------------------------------------------------------

subroutine nf_open_file(NCFILE, sFilename, iLU)

  type (T_NETCDF4_FILE ) :: NCFILE
  character (len=*) :: sFilename
  integer (c_int), optional :: iLU

  ! [ LOCALS ]
  logical (c_bool) :: lFileOpen

  call LOGS%write("Attempting to open READONLY netCDF file: " &
    //dquote(sFilename))

  call nf_trap( nc_open(trim(sFilename)//c_null_char, &
                NC_READONLY, NCFILE%iNCID), __FILE__, __LINE__ )

  call nf_trap( nc_inq_format(ncid=NCFILE%iNCID, formatp=NCFILE%iFileFormat), &
               __FILE__, __LINE__)

  call LOGS%write("   Succeeded.  ncid: "//trim(asCharacter(NCFILE%iNCID)) &
         //"  format: "//trim(NETCDF_FORMAT_STRING(NCFILE%iFileFormat) ) )

  NCFILE%sFilename = sFilename

  if( present(iLU) ) then
    inquire (unit=iLU, opened=lFileOpen)
    if ( lFileOpen )  call netcdf_dump_cdl( NCFILE, iLU)
  endif

end subroutine nf_open_file

!----------------------------------------------------------------------

subroutine netcdf_open_file(NCFILE, sFilename, iLU)

  type (T_NETCDF4_FILE ) :: NCFILE
  character (len=*) :: sFilename
  integer (c_int), optional :: iLU

  if (present(iLU) ) then

    call nf_open_file(NCFILE=NCFILE, &
                    sFilename=sFilename, &
                    iLU=iLU)

  else

    call nf_open_file(NCFILE=NCFILE, &
                    sFilename=sFilename)

  endif

  !> Similarly, the structure of the file may be slightly different from the
  !> previous file
  call nf_populate_dimension_struct( NCFILE )
  call nf_populate_variable_struct( NCFILE )

  !> CANNOT ASSUME THAT THIS WILL REMAIN CONSTANT ACROSS FILES FROM THE
  !> SAME PROVIDER!! MUST UPDATE TO ENSURE THAT THE INDICES ARE STILL RELEVANT
  call nf_get_variable_id_and_type( NCFILE )

  ! OK. We only want to attempt to call functions that
  ! process the time variable if a time variable actually exists!!
  !
  ! NOTE: this was previously coded as 'if ( NCFILE%iVarID(NC_TIME) > 0 ) then', which meant that the code
  !       failed to properly initialize the time units in the event that the TIME variable happened to be
  !       variable number 0
  !
  if ( NCFILE%iVarID(NC_TIME) >= 0 ) then

    NCFILE%dpFirstAndLastTimeValues = nf_get_first_and_last(NCFILE=NCFILE, &
        iVarIndex=NCFILE%iVarIndex(NC_TIME) )

    !> retrieve the origin for the time units associated with this file
    call nf_get_time_units(NCFILE=NCFILE)

    !> retrieve the time value specific to this file
    call nf_get_time_vals(NCFILE)

    call nf_calculate_time_range(NCFILE)

  endif

  !> establish scale_factor and add_offset values, if present
  call nf_get_scale_and_offset(NCFILE=NCFILE)

end subroutine netcdf_open_file

!----------------------------------------------------------------------

subroutine nf_trap( iResultCode, sFilename, iLineNumber, netcdf_filename )

  integer (c_int) :: iResultCode
  character (len=*), optional :: sFilename
  integer (c_int), optional :: iLineNumber
  character (len=*), optional :: netcdf_filename

  ! [ LOCALS ]
  type(c_ptr) :: cpResult
  character (len=256) :: sTextString
  character (len=256) :: sFile
  integer (c_int) :: iLine

  if (iResultCode /= 0) then

    if (present(sFilename)) then
      sFile = trim(sFilename)
    else
      sFile = __FILE__
    endif

    if (present(iLinenumber)) then
      iLine = iLinenumber
    else
      iLine = __LINE__
    endif

    cpResult = nc_strerror(iResultCode)
    sTextString = char_ptr_to_fortran_string( cpResult )

    if (present( netcdf_filename ) )                                           &
      call LOGS%write("netCDF filename: "//dquote( netcdf_filename  ) )

    call LOGS%write("netCDF ERROR: "//dquote( sTextString  )//" | error code was: " &
      //trim(asCharacter(iResultCode)) )

    call assert(FALSE, "SWB is stopping due to a problem reading or writing" &
      //" a netCDF file", trim(sFile), iLine)

  endif

end subroutine nf_trap

!----------------------------------------------------------------------

subroutine netcdf_close_file( NCFILE)

  type (T_NETCDF4_FILE ) :: NCFILE

  call LOGS%write("Closing netCDF file with name: "//dquote(NCFILE%sFilename))
  call nf_trap( nc_close(NCFILE%iNCID), __FILE__, __LINE__ )

!  call nf_deallocate_data_struct( NCFILE=NCFILE )

end subroutine netcdf_close_file

!----------------------------------------------------------------------

subroutine netcdf_deallocate_data_struct( NCFILE )

  type (T_NETCDF4_FILE ) :: NCFILE

  ! [ LOCALS ]
  type (T_NETCDF_VARIABLE), pointer :: pNC_VAR
  integer (c_int) :: iIndex

  do iIndex=0, NCFILE%iNumberOfVariables - 1

    pNC_VAR => NCFILE%pNC_VAR(iIndex)

    if (pNC_VAR%iNumberOfAttributes == 0 ) cycle

    if (associated( pNC_VAR%pNC_ATT ))  deallocate( pNC_VAR%pNC_ATT )
    pNC_VAR%pNC_ATT => null()

  enddo

  if (associated( NCFILE%pNC_VAR ))  deallocate( NCFILE%pNC_VAR )
  if (associated( NCFILE%pNC_ATT ))  deallocate( NCFILE%pNC_ATT )
  if (associated( NCFILE%pNC_DIM ))  deallocate( NCFILE%pNC_DIM )

  NCFILE%pNC_VAR => null()
  NCFILE%pNC_ATT => null()
  NCFILE%pNC_DIM => null()

end subroutine netcdf_deallocate_data_struct

!----------------------------------------------------------------------

subroutine netcdf_nullify_data_struct( NCFILE )

  type (T_NETCDF4_FILE ) :: NCFILE

  ! [ LOCALS ]

  NCFILE%pNC_VAR => null()
  NCFILE%pNC_ATT => null()
  NCFILE%pNC_DIM => null()

end subroutine netcdf_nullify_data_struct

!----------------------------------------------------------------------

subroutine nf_populate_dimension_struct( NCFILE )

  type (T_NETCDF4_FILE) :: NCFILE
  integer (c_int) :: iStat
  integer (c_int) :: iIndex
  character (len=256) :: sDimName

  call nf_trap( nc_inq_ndims(ncid=NCFILE%iNCID, ndimsp=NCFILE%iNumberOfDimensions), &
                __FILE__, __LINE__ )

  iStat = 0
  if (associated(NCFILE%pNC_DIM) ) deallocate(NCFILE%pNC_DIM, stat=iStat)
  call assert(iStat == 0, "Could not deallocate memory for NC_DIM member in NC_FILE defined type", &
    __FILE__, __LINE__)

  allocate(NCFILE%pNC_DIM( 0 : NCFILE%iNumberOfDimensions-1), stat=iStat )
  call assert(iStat == 0, "Could not allocate memory for NC_DIM member in NC_FILE defined type", &
    __FILE__, __LINE__)

  ! netCDF 3 function
  call nf_trap( nc_inq_unlimdim(ncid=NCFILE%iNCID, unlimdimidp=NCFILE%iNC3_UnlimitedDimensionNumber), &
               __FILE__, __LINE__ )

  do iIndex = 0, NCFILE%iNumberOfDimensions-1

    call nf_trap(nc_inq_dim(ncid=NCFILE%iNCID, dimid=iIndex, &
      name=sDimName, &
      lenp=NCFILE%pNC_DIM(iIndex)%iNC_DimSize), __FILE__, __LINE__ )

    NCFILE%pNC_DIM(iIndex)%iNC_DimID = iIndex
    NCFILE%pNC_DIM(iIndex)%sDimensionName = c_to_fortran_string(sDimName)

  enddo

end subroutine nf_populate_dimension_struct

!----------------------------------------------------------------------

subroutine nf_populate_variable_struct( NCFILE )

  type (T_NETCDF4_FILE) :: NCFILE

  type (T_NETCDF_ATTRIBUTE), pointer :: pNC_ATT
  type (T_NETCDF_VARIABLE), pointer :: pNC_VAR
  integer (c_int) :: iStat
  integer (c_int) :: iIndex, iIndex2 , iIndex3
  character (len=256) :: sVarName
  character (len=256) :: sAttName
  character (len=512) :: sAttValue
  integer (c_int), dimension(0:25) :: iAttValue
  integer (c_short), dimension(0:25) :: i2AttValue
  real (c_double), dimension(0:25) :: cdAttValue

  call nf_trap( nc_inq_nvars(ncid=NCFILE%iNCID, nvarsp=NCFILE%iNumberOfVariables), &
       __FILE__, __LINE__ )

  iStat = 0
  if (associated(NCFILE%pNC_VAR) ) deallocate(NCFILE%pNC_VAR, stat=iStat)
  call assert(iStat == 0, "Could not deallocate memory for NC_VAR member in NC_FILE defined type", &
    __FILE__, __LINE__)

  allocate(NCFILE%pNC_VAR( 0 : NCFILE%iNumberOfVariables-1), stat=iStat )
  call assert(iStat == 0, "Could not allocate memory for NC_VAR member in NC_FILE defined type", &
    __FILE__, __LINE__)

  do iIndex = 0, NCFILE%iNumberOfVariables-1

    pNC_VAR => NCFILE%pNC_VAR(iIndex)

    call nf_trap(nc_inq_var(ncid=NCFILE%iNCID, &
        varid=iIndex, &
        name=sVarName, &
        xtypep=pNC_VAR%iNC_VarType, &
        ndimsp=pNC_VAR%iNumberOfDimensions, &
        dimidsp=pNC_VAR%iNC_DimID, &
        nattsp=pNC_VAR%iNumberOfAttributes ), __FILE__, __LINE__ )

    pNC_VAR%iNC_VarID = iIndex
    pNC_VAR%sVariableName = c_to_fortran_string(sVarName)

    if( pNC_VAR%iNumberOfAttributes > 0 ) then

      if (associated(pNC_VAR%pNC_ATT) ) deallocate(pNC_VAR%pNC_ATT, stat=iStat)
      call assert(iStat == 0, "Could not deallocate memory for NC_ATT member within NC_VAR in NC_FILE defined type", &
        __FILE__, __LINE__)

      allocate( pNC_VAR%pNC_ATT( 0:pNC_VAR%iNumberOfAttributes - 1 ), stat = iStat)
      call assert(iStat == 0, "Could not allocate memory for NC_ATT member within NC_VAR in NC_FILE defined type", &
        __FILE__, __LINE__)

      do iIndex2=0, pNC_VAR%iNumberOfAttributes - 1

        pNC_ATT => pNC_VAR%pNC_ATT(iIndex2)

        call nf_populate_attribute_struct( NCFILE=NCFILE, pNC_ATT=pNC_ATT, &
          iNC_VarID=iIndex, iAttNum=iIndex2 )

      enddo

    endif

  enddo

  call nf_trap( nc_inq_natts(ncid=NCFILE%iNCID, ngattsp=NCFILE%iNumberOfAttributes), &
       __FILE__, __LINE__ )


  if (associated(NCFILE%pNC_ATT) )  deallocate(NCFILE%pNC_ATT, stat=iStat)
  call assert(iStat == 0, "Could not deallocate memory for NC_ATT member within NC_FILE defined type", &
    __FILE__, __LINE__)

  allocate(NCFILE%pNC_ATT(0:NCFILE%iNumberOfAttributes - 1), stat=iStat )
  call assert(iStat == 0, "Could not allocate memory for NC_ATT member within NC_FILE defined type", &
    __FILE__, __LINE__)

  do iIndex=0, NCFILE%iNumberOfAttributes - 1
    pNC_ATT => NCFILE%pNC_ATT(iIndex)

    call nf_populate_attribute_struct( NCFILE=NCFILE, pNC_ATT=pNC_ATT, &
      iNC_VarID=NC_GLOBAL, iAttNum=iIndex )

  enddo

end subroutine nf_populate_variable_struct

!----------------------------------------------------------------------

subroutine nf_populate_attribute_struct( NCFILE, pNC_ATT, iNC_VarID, iAttNum )

  type (T_NETCDF4_FILE), intent(inout) :: NCFILE
  type (T_NETCDF_ATTRIBUTE), pointer :: pNC_ATT
  integer (c_int) :: iNC_VarID
  integer (c_int) :: iAttNum

  ![ LOCALS ]
  integer (c_int) :: iStat
  character (len=256) :: sVarName
  character (len=256) :: sAttName
  integer (c_int) :: iIndex
  integer (c_int) :: iLength

  call nf_trap( nc_inq_attname(ncid=NCFILE%iNCID, &
    varid=iNC_VarID, &
    attnum=iAttNum, &
    name=sAttName), __FILE__, __LINE__ )

  pNC_ATT%sAttributeName = c_to_fortran_string(sAttName)

  call nf_trap( nc_inq_att(ncid=NCFILE%iNCID, &
    varid=iNC_VarID, &
    name=sAttName, &
    xtypep=pNC_ATT%iNC_AttType, &
    lenp=pNC_ATT%iNC_AttSize), __FILE__, __LINE__ )

  iLength = pNC_ATT%iNC_AttSize

  iStat = 0
  allocate(pNC_ATT%sAttValue(0:iLength-1), stat=iStat )
  call assert(iStat==0, "INTERNAL PROGRAMMING ERROR - problem allocating memory", &
    __FILE__, __LINE__)
  pNC_ATT%sAttValue = ""

  select case(pNC_ATT%iNC_AttType)

    case (NC_CHAR)

      call nf_trap( nc_get_att_text(ncid=NCFILE%iNCID, &
        varid=iNC_VarID, &
        name=sAttName, &
        ip=pNC_ATT%sAttValue), __FILE__, __LINE__ )

        pNC_ATT%sAttValue = c_to_fortran_string(pNC_ATT%sAttValue)

    case (NC_SHORT)

      allocate(pNC_ATT%i2AttValue(0:iLength-1), stat=iStat )
      call assert(iStat==0, "INTERNAL PROGRAMMING ERROR - problem allocating memory", &
        __FILE__, __LINE__)


      call nf_trap( nc_get_att_short(ncid=NCFILE%iNCID, &
        varid=iNC_VarID, &
        name=sAttName, &
        ip=pNC_ATT%i2AttValue), __FILE__, __LINE__ )

      do iIndex=1,ubound(pNC_ATT%i2AttValue,1)
        pNC_ATT%sAttValue(iIndex) = asCharacter(pNC_ATT%i2AttValue(iIndex))
      enddo

    case (NC_INT)

      allocate(pNC_ATT%iAttValue(0:iLength-1), stat=iStat )
      call assert(iStat==0, "INTERNAL PROGRAMMING ERROR - problem allocating memory", &
        __FILE__, __LINE__)

      call nf_trap( nc_get_att_int(ncid=NCFILE%iNCID, &
        varid=iNC_VarID, &
        name=sAttName, &
        ip=pNC_ATT%iAttValue), __FILE__, __LINE__ )

      do iIndex=1,ubound(pNC_ATT%iAttValue,1)
        pNC_ATT%sAttValue(iIndex) = asCharacter(pNC_ATT%iAttValue(iIndex))
      enddo

    case (NC_FLOAT)

      allocate(pNC_ATT%rAttValue(0:iLength-1), stat=iStat )
      call assert(iStat==0, "INTERNAL PROGRAMMING ERROR - problem allocating memory", &
        __FILE__, __LINE__)


      call nf_trap( nc_get_att_float(ncid=NCFILE%iNCID, &
        varid=iNC_VarID, &
        name=sAttName, &
        ip=pNC_ATT%rAttValue), __FILE__, __LINE__ )

      do iIndex=1,ubound(pNC_ATT%rAttValue,1)
        pNC_ATT%sAttValue(iIndex) = asCharacter(pNC_ATT%rAttValue(iIndex))
      enddo

    case (NC_DOUBLE)

      allocate(pNC_ATT%dpAttValue(0:iLength-1), stat=iStat )
      call assert(iStat==0, "INTERNAL PROGRAMMING ERROR - problem allocating memory", &
        __FILE__, __LINE__)

      call nf_trap( nc_get_att_double(ncid=NCFILE%iNCID, &
        varid=iNC_VarID, &
        name=sAttName, &
        ip=pNC_ATT%dpAttValue), __FILE__, __LINE__ )

      do iIndex=1,ubound(pNC_ATT%dpAttValue,1)
        pNC_ATT%sAttValue(iIndex) = asCharacter(pNC_ATT%dpAttValue(iIndex))
      enddo

    case default

  end select

end subroutine nf_populate_attribute_struct

!----------------------------------------------------------------------


subroutine netcdf_get_variable_id_for_variable( NCFILE, variable_name, &
                                                variable_id      )

  type (T_NETCDF4_FILE), intent(inout) :: NCFILE
  character (len=*), intent(in)        :: variable_name
  integer (c_int), intent(out)    :: variable_id

  ! [ LOCALS ]
  integer (c_int) :: indx
  type (T_NETCDF_VARIABLE), pointer  :: pNC_VAR
  logical (c_bool)              :: variable_was_found
  character (len=256)                :: tempstring

  variable_was_found = FALSE

  do indx=0, NCFILE%iNumberOfVariables-1
    pNC_VAR => NCFILE%pNC_VAR( indx )
    if ( associated( pNC_VAR ) ) then
      if ( pNC_VAR%sVariableName .strequal. variable_name ) then
        variable_was_found = TRUE
        exit
      endif
    endif
  enddo

  if ( variable_was_found ) then

    variable_id = pNC_VAR%iNC_VarID

  else

    variable_id = -9999

  endif

end subroutine netcdf_get_variable_id_for_variable

!--------------------------------------------------------------------------------------------------

subroutine netcdf_get_attribute_list_for_variable( NCFILE, variable_name, &
                                                   attribute_name_list,   &
                                                   attribute_value_list )

  type (T_NETCDF4_FILE), intent(inout) :: NCFILE
  character (len=*), intent(in)        :: variable_name
  type (FSTRING_LIST_T), intent(out)    :: attribute_name_list
  type (FSTRING_LIST_T), intent(out)    :: attribute_value_list

  ! [ LOCALS ]
  integer (c_int) :: indx
  type (T_NETCDF_ATTRIBUTE), pointer :: pNC_ATT
  type (T_NETCDF_VARIABLE), pointer  :: pNC_VAR
  logical (c_bool)              :: variable_was_found
  character (len=256)                :: tempstring

  variable_was_found = FALSE

  call attribute_name_list%clear
  call attribute_value_list%clear

  do indx=0, NCFILE%iNumberOfVariables-1
    pNC_VAR => NCFILE%pNC_VAR( indx )
    if ( associated( pNC_VAR ) ) then
      if ( pNC_VAR%sVariableName .strequal. variable_name ) then
        variable_was_found = TRUE
        exit
      endif
    endif
  enddo

  if ( variable_was_found ) then

    do indx=0, pNC_VAR%iNumberOfAttributes-1
      pNC_ATT => pNC_VAR%pNC_ATT( indx )
      if (associated( pNC_ATT) ) then

        tempstring = pNC_ATT%sAttributeName
        call attribute_name_list%append( trim( tempstring ) )

        select case ( pNC_ATT%iNC_AttType )

          case ( NC_CHAR )

            tempstring = pNC_ATT%sAttValue(0)
            call attribute_value_list%append( trim( tempstring ) )

          case ( NC_SHORT )

            tempstring = asCharacter( pNC_ATT%i2AttValue(0) )
            call attribute_value_list%append( trim( tempstring ) )

          case ( NC_INT )

            tempstring = asCharacter ( pNC_ATT%iAttValue(0) )
            call attribute_value_list%append( trim( tempstring ) )

          case ( NC_FLOAT )

            tempstring = asCharacter( pNC_ATT%rAttValue(0) )
            call attribute_value_list%append( trim( tempstring ) )

          case ( NC_DOUBLE )

            tempstring = asCharacter( pNC_ATT%dpAttValue(0) )
            call attribute_value_list%append( trim( tempstring ) )

        end select

      endif

    enddo

  else

    call attribute_name_list%append("<NA>")
    call attribute_value_list%append("<NA>")

  endif

end subroutine netcdf_get_attribute_list_for_variable

!----------------------------------------------------------------------

subroutine netcdf_set_coordinate_tolerance(NCFILE, tolerance)

  type (T_NETCDF4_FILE)        :: NCFILE
  real (c_double), intent(in)  :: tolerance

  NCFILE%rCoordinateTolerance = tolerance

end subroutine netcdf_set_coordinate_tolerance

!----------------------------------------------------------------------

subroutine netcdf_get_variable_list( NCFILE, variable_list )

  type (T_NETCDF4_FILE) :: NCFILE
  type (FSTRING_LIST_T)  :: variable_list

  ! [ LOCALS ]
  integer (c_int) :: indx
  type (T_NETCDF_ATTRIBUTE), pointer :: pNC_ATT
  type (T_NETCDF_VARIABLE), pointer :: pNC_VAR

  call variable_list%clear

  do indx=0, NCFILE%iNumberOfVariables-1
    pNC_VAR => NCFILE%pNC_VAR( indx )
    if ( associated( pNC_VAR ) )  call variable_list%append( pNC_VAR%sVariableName )
  enddo

end subroutine netcdf_get_variable_list

!----------------------------------------------------------------------

function netcdf_update_time_starting_index(NCFILE, iJulianDay)  result(lDateTimeFound)

  type (T_NETCDF4_FILE) :: NCFILE
  integer (c_int) :: iJulianDay
  logical (c_bool) :: lDateTimeFound

  ! [ LOCALS ]
  real (c_double) :: rNC_DateTime

  NCFILE%iStart(NC_TIME) = nf_julian_day_to_index_adj( NCFILE=NCFILE, &
                                     rJulianDay=real(iJulianDay, c_double ) )

  if (NCFILE%iStart(NC_TIME) < 0) then
    NCFILE%iStart(NC_TIME) = 0
    lDateTimeFound = FALSE
  else
    lDateTimeFound = TRUE
  endif

end function netcdf_update_time_starting_index

!----------------------------------------------------------------------

subroutine netcdf_get_variable_slice(NCFILE, rValues, dpValues, iValues)

  type (T_NETCDF4_FILE), intent(inout)       :: NCFILE
  real (c_float), dimension(:,:), optional   :: rValues
  real (c_double), dimension(:,:), optional  :: dpValues
  integer (c_int), dimension(:,:), optional  :: iValues

  real (c_float), allocatable     :: rTempVals(:,:)
  integer (c_short), allocatable  :: i2TempVals(:,:)
  integer (c_int), allocatable    :: iTempVals(:,:)
  real (c_double), allocatable    :: dpTempVals(:,:)
  integer (c_int)                 :: nrow, ncol

  if (present( rValues) ) then
    nrow = size(rValues,2)
    ncol = size(rValues,1)
  elseif (present( dpValues) ) then
    nrow = size(dpValues,2)
    ncol = size(dpValues,1)
  elseif (present( iValues) ) then
    nrow = size(iValues,2)
    ncol = size(iValues,1)
  else
    call die("Internal programming error: unhandled data type",                &
      __FILE__, __LINE__)
  endif

  if (   NCFILE%iVarType(NC_Z) == NC_SHORT                                     &
    .or. NCFILE%iVarType(NC_Z) == NC_USHORT) then

    allocate( i2TempVals(ncol, nrow))

    call nf_get_variable_slice_short(NCFILE, i2TempVals)

    if (present(rValues))  rValues = asFloat(i2TempVals)
    if (present(iValues))  iValues = i2TempVals
    if (present(dpValues))  dpValues = asDouble(i2TempVals)

  elseif (   NCFILE%iVarType(NC_Z) == NC_INT                                   &
    .or. NCFILE%iVarType(NC_Z) == NC_UINT) then

    allocate( iTempVals(ncol, nrow))
    call nf_get_variable_slice_int(NCFILE, iTempVals)

    if (present(rValues))  rValues = asFloat(iTempVals)
    if (present(iValues))  iValues = iTempVals
    if (present(dpValues))  dpValues = asDouble(iTempVals)

  elseif (NCFILE%iVarType(NC_Z) == NC_FLOAT) then

    allocate( rTempVals(ncol, nrow))
    call nf_get_variable_slice_float(NCFILE, rTempVals)

    if (present(rValues))  rValues = rTempVals
    if (present(iValues))  iValues = asInt(rTempVals)
    if (present(dpValues))  dpValues = asDouble(rTempVals)

  elseif (NCFILE%iVarType(NC_Z) == NC_DOUBLE) then

    allocate( dpTempVals(ncol, nrow))
    call nf_get_variable_slice_double(NCFILE, dpTempVals)

    if (present(rValues))  rValues = asFloat(dpTempVals)
    if (present(iValues))  iValues = asInt(dpTempVals)
    if (present(dpValues))  dpValues = dpTempVals

  else

    call warn("Failed to find a method to retrieve data of the given type.", __FILE__, __LINE__)

    print *, 'var type: ',NCFILE%iVarType(NC_Z)

  endif

end subroutine netcdf_get_variable_slice

!----------------------------------------------------------------------

subroutine nf_get_variable_slice_short(NCFILE, i2Values)

  type (T_NETCDF4_FILE) :: NCFILE
  integer (c_short), intent(inout) :: i2Values(:,:)

  ! [ LOCALS ]
  !! dimension #1 = column (iNX)
  type (T_NETCDF_VARIABLE), pointer :: pNC_VAR

  integer (c_short), dimension(size(i2Values,2) * size(i2Values,1)) :: iTemp

  integer (c_int) :: iStat
  integer (c_int) :: iRow, iCol, iIndex
  integer (c_int) :: iFromRow, iToRow, iByRow
  integer (c_int) :: iFromCol, iToCol, iByCol

  iFromRow = NCFILE%iRowIter(NC_FIRST)
  iToRow = NCFILE%iRowIter(NC_LAST)
  iByRow = NCFILE%iRowIter(NC_BY)

  iFromCol = NCFILE%iColIter(NC_FIRST)
  iToCol = NCFILE%iColIter(NC_LAST)
  iByCol = NCFILE%iColIter(NC_BY)

  pNC_VAR => NCFILE%pNC_VAR(nf_return_VarIndex( NCFILE, NCFILE%iVarID(NC_Z)) )

  select case (NCFILE%sVariableOrder)

    case ("txy")    ! time, col, row

      call nf_get_variable_array_as_vector_short(NCFILE=NCFILE, &
        iNC_VarID=NCFILE%iVarID(NC_Z), &
        iNC_Start=[NCFILE%iStart(NC_TIME), NCFILE%iStart(NC_X), NCFILE%iStart(NC_Y)], &
        iNC_Count=[NCFILE%iCount(NC_TIME), NCFILE%iCount(NC_X), NCFILE%iCount(NC_Y)], &
        iNC_Stride=[NCFILE%iStride(NC_TIME), NCFILE%iStride(NC_X), NCFILE%iStride(NC_Y)], &
        iNC_Vars=iTemp)

        iIndex = 0
        do iCol=iFromCol, iToCol, iByCol
          do iRow=iFromRow, iToRow, iByRow
            iIndex = iIndex + 1
            i2Values(iCol,iRow) = iTemp(iIndex)
          enddo
        enddo

    case ("tyx")    ! time, row, col

      call nf_get_variable_array_as_vector_short(NCFILE=NCFILE, &
        iNC_VarID=NCFILE%iVarID(NC_Z), &
        iNC_Start=[NCFILE%iStart(NC_TIME), NCFILE%iStart(NC_Y), NCFILE%iStart(NC_X)], &
        iNC_Count=[NCFILE%iCount(NC_TIME), NCFILE%iCount(NC_Y), NCFILE%iCount(NC_X)], &
        iNC_Stride=[NCFILE%iStride(NC_TIME), NCFILE%iStride(NC_Y), NCFILE%iStride(NC_X)], &
        iNC_Vars=iTemp)

        iIndex = 0
        do iRow=iFromRow, iToRow, iByRow
          do iCol=iFromCol, iToCol, iByCol
            iIndex = iIndex + 1
            i2Values(iCol,iRow) = iTemp(iIndex)
          enddo
        enddo

    case default

      call warn("INTERNAL PROGRAMMING ERROR: Unhandled select case. Program will probably fail.", __FILE__, __LINE__)

  end select

end subroutine nf_get_variable_slice_short

!----------------------------------------------------------------------

subroutine nf_get_variable_slice_int(NCFILE, iValues)

  type (T_NETCDF4_FILE) :: NCFILE
  integer (c_int), dimension(:,:) :: iValues

  ! [ LOCALS ]
  !! dimension #1 = column (iNX)
  type (T_NETCDF_VARIABLE), pointer :: pNC_VAR

  integer (c_int), dimension(size(iValues,2) * size(iValues,1)) :: iTemp

  integer (c_int) :: iStat
  integer (c_int) :: iRow, iCol, iIndex
  integer (c_int) :: iFromRow, iToRow, iByRow
  integer (c_int) :: iFromCol, iToCol, iByCol

  iFromRow = NCFILE%iRowIter(NC_FIRST)
  iToRow = NCFILE%iRowIter(NC_LAST)
  iByRow = NCFILE%iRowIter(NC_BY)

  iFromCol = NCFILE%iColIter(NC_FIRST)
  iToCol = NCFILE%iColIter(NC_LAST)
  iByCol = NCFILE%iColIter(NC_BY)

  pNC_VAR => NCFILE%pNC_VAR(nf_return_VarIndex( NCFILE, NCFILE%iVarID(NC_Z)) )

  select case (NCFILE%sVariableOrder)

    case ("txy")    ! time, col, row

      call nf_get_variable_array_as_vector_int(NCFILE=NCFILE, &
        iNC_VarID=NCFILE%iVarID(NC_Z), &
        iNC_Start=[NCFILE%iStart(NC_TIME), NCFILE%iStart(NC_X), NCFILE%iStart(NC_Y)], &
        iNC_Count=[NCFILE%iCount(NC_TIME), NCFILE%iCount(NC_X), NCFILE%iCount(NC_Y)], &
        iNC_Stride=[NCFILE%iStride(NC_TIME), NCFILE%iStride(NC_X), NCFILE%iStride(NC_Y)], &
        iNC_Vars=iTemp)

        iIndex = 0
        do iCol=iFromCol, iToCol, iByCol
          do iRow=iFromRow, iToRow, iByRow
            iIndex = iIndex + 1
            iValues(iCol,iRow) = iTemp(iIndex)
          enddo
        enddo

    case ("tyx")    ! time, row, col

      call nf_get_variable_array_as_vector_int(NCFILE=NCFILE, &
        iNC_VarID=NCFILE%iVarID(NC_Z), &
        iNC_Start=[NCFILE%iStart(NC_TIME), NCFILE%iStart(NC_Y), NCFILE%iStart(NC_X)], &
        iNC_Count=[NCFILE%iCount(NC_TIME), NCFILE%iCount(NC_Y), NCFILE%iCount(NC_X)], &
        iNC_Stride=[NCFILE%iStride(NC_TIME), NCFILE%iStride(NC_Y), NCFILE%iStride(NC_X)], &
        iNC_Vars=iTemp)

        iIndex = 0
        do iRow=iFromRow, iToRow, iByRow
          do iCol=iFromCol, iToCol, iByCol
            iIndex = iIndex + 1
            iValues(iCol,iRow) = iTemp(iIndex)
          enddo
        enddo

    case default

      call warn("INTERNAL PROGRAMMING ERROR: Unhandled select case. Program will probably fail.", __FILE__, __LINE__)


  end select

end subroutine nf_get_variable_slice_int

!----------------------------------------------------------------------

subroutine nf_get_variable_slice_float(NCFILE, rValues)

  type (T_NETCDF4_FILE) :: NCFILE
  real (c_float), dimension(:,:) :: rValues

  ! [ LOCALS ]
  type (T_NETCDF_VARIABLE), pointer :: pNC_VAR
  real (c_float), dimension(size(rValues,2) * size(rValues,1)) :: rTemp
  integer (c_int) :: iStat
  integer (c_int) :: iRow, iCol, iIndex
  integer (c_int) :: iFromRow, iToRow, iByRow
  integer (c_int) :: iFromCol, iToCol, iByCol

  iFromRow = NCFILE%iRowIter(NC_FIRST)
  iToRow = NCFILE%iRowIter(NC_LAST)
  iByRow = NCFILE%iRowIter(NC_BY)

  iFromCol = NCFILE%iColIter(NC_FIRST)
  iToCol = NCFILE%iColIter(NC_LAST)
  iByCol = NCFILE%iColIter(NC_BY)

  pNC_VAR => NCFILE%pNC_VAR(nf_return_VarIndex( NCFILE, NCFILE%iVarID(NC_Z)) )

  select case (NCFILE%sVariableOrder)

    case ("txy")    ! time, col, row

      call nf_get_variable_array_as_vector_float(NCFILE=NCFILE, &
        iNC_VarID=NCFILE%iVarID(NC_Z), &
        iNC_Start=[NCFILE%iStart(NC_TIME), NCFILE%iStart(NC_X), NCFILE%iStart(NC_Y)], &
        iNC_Count=[NCFILE%iCount(NC_TIME), NCFILE%iCount(NC_X), NCFILE%iCount(NC_Y)], &
        iNC_Stride=[NCFILE%iStride(NC_TIME), NCFILE%iStride(NC_X), NCFILE%iStride(NC_Y)], &
        rNC_Vars=rTemp)

      iIndex = 0
      do iCol=iFromCol, iToCol, iByCol
        do iRow=iFromRow, iToRow, iByRow
          iIndex = iIndex + 1
          rValues(iCol,iRow) = rTemp(iIndex)
        enddo
      enddo

    case ("tyx")    ! time, row, col

      call nf_get_variable_array_as_vector_float(NCFILE=NCFILE, &
        iNC_VarID=NCFILE%iVarID(NC_Z), &
        iNC_Start=[NCFILE%iStart(NC_TIME), NCFILE%iStart(NC_Y), NCFILE%iStart(NC_X)], &
        iNC_Count=[NCFILE%iCount(NC_TIME), NCFILE%iCount(NC_Y), NCFILE%iCount(NC_X)], &
        iNC_Stride=[NCFILE%iStride(NC_TIME), NCFILE%iStride(NC_Y), NCFILE%iStride(NC_X)], &
        rNC_Vars=rTemp)

      iIndex = 0
      do iRow=iFromRow, iToRow, iByRow
        do iCol=iFromCol, iToCol, iByCol
          iIndex = iIndex + 1
          rValues(iCol,iRow) = rTemp(iIndex)
        enddo
      enddo

    case default

      call warn("INTERNAL PROGRAMMING ERROR: Unhandled select case. Program will probably fail.", __FILE__, __LINE__)

  end select

end subroutine nf_get_variable_slice_float

!----------------------------------------------------------------------

subroutine nf_get_variable_slice_double(NCFILE, dpValues)

  type (T_NETCDF4_FILE) :: NCFILE
  real (c_double), dimension(:,:) :: dpValues

  ! [ LOCALS ]
  type (T_NETCDF_VARIABLE), pointer :: pNC_VAR
  real (c_double), dimension(size(dpValues,2) * size(dpValues,1)) :: dpTemp
  integer (c_int) :: iStat
  integer (c_int) :: iRow, iCol, iIndex
  integer (c_int) :: iFromRow, iToRow, iByRow
  integer (c_int) :: iFromCol, iToCol, iByCol

  iFromRow = NCFILE%iRowIter(NC_FIRST)
  iToRow = NCFILE%iRowIter(NC_LAST)
  iByRow = NCFILE%iRowIter(NC_BY)

  iFromCol = NCFILE%iColIter(NC_FIRST)
  iToCol = NCFILE%iColIter(NC_LAST)
  iByCol = NCFILE%iColIter(NC_BY)

  pNC_VAR => NCFILE%pNC_VAR(nf_return_VarIndex( NCFILE, NCFILE%iVarID(NC_Z)) )

  select case (NCFILE%sVariableOrder)

    case ("txy")    ! time, col, row

      call nf_get_variable_array_as_vector_double(NCFILE=NCFILE, &
        iNC_VarID=NCFILE%iVarID(NC_Z), &
        iNC_Start=[NCFILE%iStart(NC_TIME), NCFILE%iStart(NC_X), NCFILE%iStart(NC_Y)], &
        iNC_Count=[NCFILE%iCount(NC_TIME), NCFILE%iCount(NC_X), NCFILE%iCount(NC_Y)], &
        iNC_Stride=[NCFILE%iStride(NC_TIME), NCFILE%iStride(NC_X), NCFILE%iStride(NC_Y)], &
        dpNC_Vars=dpTemp)

      iIndex = 0
      do iCol=iFromCol, iToCol, iByCol
        do iRow=iFromRow, iToRow, iByRow
          iIndex = iIndex + 1
          dpValues(iCol,iRow) = dpTemp(iIndex)
        enddo
      enddo

    case ("tyx")    ! time, row, col

      call nf_get_variable_array_as_vector_double(NCFILE=NCFILE, &
        iNC_VarID=NCFILE%iVarID(NC_Z), &
        iNC_Start=[NCFILE%iStart(NC_TIME), NCFILE%iStart(NC_Y), NCFILE%iStart(NC_X)], &
        iNC_Count=[NCFILE%iCount(NC_TIME), NCFILE%iCount(NC_Y), NCFILE%iCount(NC_X)], &
        iNC_Stride=[NCFILE%iStride(NC_TIME), NCFILE%iStride(NC_Y), NCFILE%iStride(NC_X)], &
        dpNC_Vars=dpTemp)

      iIndex = 0
      do iRow=iFromRow, iToRow, iByRow
        do iCol=iFromCol, iToCol, iByCol
          iIndex = iIndex + 1
          dpValues(iCol,iRow) = dpTemp(iIndex)
        enddo
      enddo

    case default

      call warn("INTERNAL PROGRAMMING ERROR: Unhandled select case. Program will probably fail.", __FILE__, __LINE__)

  end select

end subroutine nf_get_variable_slice_double

!----------------------------------------------------------------------

subroutine nf_get_variable_vector_short(NCFILE, iNC_VarID, iNC_Start, iNC_Count, &
   iNC_Stride, iNC_Vars)

  type (T_NETCDF4_FILE), intent(inout) :: NCFILE
  integer (c_int) :: iNC_VarID
  integer (c_size_t) :: iNC_Start
  integer (c_size_t) :: iNC_Count
  integer (c_size_t) :: iNC_Stride
  integer (c_short), dimension(:) :: iNC_Vars

  call nf_trap(nc_get_vars_short(ncid=NCFILE%iNCID, &
       varid=iNC_VarID, &
       startp=[iNC_Start], &
       countp=[iNC_Count], &
       stridep=[iNC_Stride], &
       vars=iNC_Vars), __FILE__, __LINE__ )

end subroutine nf_get_variable_vector_short

!----------------------------------------------------------------------

subroutine nf_get_variable_array_short(NCFILE, iNC_VarID, iNC_Start, iNC_Count, &
   iNC_Stride, iNC_Vars)

  type (T_NETCDF4_FILE), intent(inout) :: NCFILE
  integer (c_int) :: iNC_VarID
  integer (c_size_t), dimension(:) :: iNC_Start
  integer (c_size_t), dimension(:) :: iNC_Count
  integer (c_size_t), dimension(:) :: iNC_Stride
  integer (c_short), dimension(:,:) :: iNC_Vars

  call nf_trap(nc_get_vars_short(ncid=NCFILE%iNCID, &
       varid=iNC_VarID, &
       startp=[iNC_Start], &
       countp=[iNC_Count], &
       stridep=[iNC_Stride], &
       vars=iNC_Vars), __FILE__, __LINE__ )

end subroutine nf_get_variable_array_short

!----------------------------------------------------------------------

subroutine nf_get_variable_array_as_vector_short(NCFILE, iNC_VarID, iNC_Start, iNC_Count, &
   iNC_Stride, iNC_Vars)

  type (T_NETCDF4_FILE), intent(inout) :: NCFILE
  integer (c_int) :: iNC_VarID
  integer (c_size_t), dimension(:) :: iNC_Start
  integer (c_size_t), dimension(:) :: iNC_Count
  integer (c_size_t), dimension(:) :: iNC_Stride
  integer (c_short), dimension(:) :: iNC_Vars

  call nf_trap(nc_get_vars_short(ncid=NCFILE%iNCID, &
       varid=iNC_VarID, &
       startp=[iNC_Start], &
       countp=[iNC_Count], &
       stridep=[iNC_Stride], &
       vars=iNC_Vars), __FILE__, __LINE__ )

end subroutine nf_get_variable_array_as_vector_short

!----------------------------------------------------------------------

subroutine nf_get_variable_array_as_vector_int(NCFILE, iNC_VarID, iNC_Start, iNC_Count, &
   iNC_Stride, iNC_Vars)

  type (T_NETCDF4_FILE), intent(inout)     :: NCFILE
  integer (c_int)                     :: iNC_VarID
  integer (c_size_t), dimension(:)    :: iNC_Start
  integer (c_size_t), dimension(:)    :: iNC_Count
  integer (c_size_t), dimension(:) :: iNC_Stride
  integer (c_int), dimension(:)       :: iNC_Vars

  call nf_trap(nc_get_vars_int(ncid=NCFILE%iNCID, &
       varid=iNC_VarID, &
       startp=[iNC_Start], &
       countp=[iNC_Count], &
       stridep=[iNC_Stride], &
       vars=iNC_Vars), __FILE__, __LINE__ )

end subroutine nf_get_variable_array_as_vector_int

!----------------------------------------------------------------------

subroutine nf_get_variable_vector_int(NCFILE, iNC_VarID, iNC_Start, iNC_Count, &
   iNC_Stride, iNC_Vars)

  type (T_NETCDF4_FILE), intent(inout) :: NCFILE
  integer (c_int) :: iNC_VarID
  integer (c_size_t) :: iNC_Start
  integer (c_size_t) :: iNC_Count
  integer (c_size_t) :: iNC_Stride
  integer (c_int), dimension(:) :: iNC_Vars

  call nf_trap(nc_get_vars_int(ncid=NCFILE%iNCID, &
       varid=iNC_VarID, &
       startp=[iNC_Start], &
       countp=[iNC_Count], &
       stridep=[iNC_Stride], &
       vars=iNC_Vars), __FILE__, __LINE__ )

end subroutine nf_get_variable_vector_int

!----------------------------------------------------------------------

subroutine nf_get_variable_vector_double(NCFILE, iNC_VarID, iNC_Start, iNC_Count, &
   iNC_Stride, dpNC_Vars)

  type (T_NETCDF4_FILE), intent(inout) :: NCFILE
  integer (c_int) :: iNC_VarID
  integer (c_size_t) :: iNC_Start
  integer (c_size_t) :: iNC_Count
  integer (c_size_t) :: iNC_Stride
  real (c_double), dimension(:) :: dpNC_Vars

  call nf_trap(nc_get_vars_double(ncid=NCFILE%iNCID, &
       varid=iNC_VarID, &
       startp=[iNC_Start], &
       countp=[iNC_Count], &
       stridep=[iNC_Stride], &
       vars=dpNC_Vars), __FILE__, __LINE__ )

end subroutine nf_get_variable_vector_double

!----------------------------------------------------------------------

subroutine nf_get_variable_array_double(NCFILE, iNC_VarID, iNC_Start, iNC_Count, &
   iNC_Stride, dpNC_Vars)

  type (T_NETCDF4_FILE), intent(inout) :: NCFILE
  integer (c_int) :: iNC_VarID
  integer (c_size_t), dimension(:) :: iNC_Start
  integer (c_size_t), dimension(:) :: iNC_Count
  integer (c_size_t), dimension(:) :: iNC_Stride
  real (c_double), dimension(:,:) :: dpNC_Vars

  call nf_trap(nc_get_vars_double(ncid=NCFILE%iNCID, &
       varid=iNC_VarID, &
       startp=[iNC_Start], &
       countp=[iNC_Count], &
       stridep=[iNC_Stride], &
       vars=dpNC_Vars), __FILE__, __LINE__ )

end subroutine nf_get_variable_array_double

!----------------------------------------------------------------------

subroutine nf_get_variable_array_as_vector_double(NCFILE, iNC_VarID, iNC_Start, iNC_Count, &
   iNC_Stride, dpNC_Vars)

  type (T_NETCDF4_FILE), intent(inout) :: NCFILE
  integer (c_int) :: iNC_VarID
  integer (c_size_t), dimension(:) :: iNC_Start
  integer (c_size_t), dimension(:) :: iNC_Count
  integer (c_size_t), dimension(:) :: iNC_Stride
  real (c_double), dimension(:) :: dpNC_Vars

  call nf_trap(nc_get_vars_double(ncid=NCFILE%iNCID, &
       varid=iNC_VarID, &
       startp=[iNC_Start], &
       countp=[iNC_Count], &
       stridep=[iNC_Stride], &
       vars=dpNC_Vars), __FILE__, __LINE__ )

end subroutine nf_get_variable_array_as_vector_double

!----------------------------------------------------------------------

subroutine nf_get_variable_vector_float(NCFILE, iNC_VarID, iNC_Start, iNC_Count, &
   iNC_Stride, rNC_Vars )

  type (T_NETCDF4_FILE), intent(inout) :: NCFILE
  integer (c_int) :: iNC_VarID
  integer (c_size_t) :: iNC_Start
  integer (c_size_t) :: iNC_Count
  integer (c_size_t) :: iNC_Stride
  real (c_float), dimension(:) :: rNC_Vars

  call nf_trap(nc_get_vars_float(ncid=NCFILE%iNCID, &
       varid=iNC_VarID, &
       startp=[iNC_Start], &
       countp=[iNC_Count], &
       stridep=[iNC_Stride], &
       vars=rNC_Vars), __FILE__, __LINE__ )

end subroutine nf_get_variable_vector_float

!----------------------------------------------------------------------

subroutine nf_get_variable_array_float(NCFILE, iNC_VarID, iNC_Start, iNC_Count, &
   iNC_Stride, rNC_Vars )

  type (T_NETCDF4_FILE), intent(inout) :: NCFILE
  integer (c_int) :: iNC_VarID
  integer (c_size_t), dimension(:) :: iNC_Start
  integer (c_size_t), dimension(:) :: iNC_Count
  integer (c_size_t), dimension(:) :: iNC_Stride
  real (c_float), dimension(:,:) :: rNC_Vars

  call nf_trap(nc_get_vars_float(ncid=NCFILE%iNCID, &
       varid=iNC_VarID, &
       startp=[iNC_Start], &
       countp=[iNC_Count], &
       stridep=[iNC_Stride], &
       vars=rNC_Vars), __FILE__, __LINE__ )

end subroutine nf_get_variable_array_float

!----------------------------------------------------------------------

subroutine nf_get_variable_array_as_vector_float(NCFILE, iNC_VarID, iNC_Start, iNC_Count, &
   iNC_Stride, rNC_Vars )

  type (T_NETCDF4_FILE), intent(inout) :: NCFILE
  integer (c_int) :: iNC_VarID
  integer (c_size_t), dimension(:) :: iNC_Start
  integer (c_size_t), dimension(:) :: iNC_Count
  integer (c_size_t), dimension(:) :: iNC_Stride
  real (c_float), dimension(:) :: rNC_Vars

  call nf_trap(nc_get_vars_float(ncid=NCFILE%iNCID, &
       varid=iNC_VarID, &
       startp=[iNC_Start], &
       countp=[iNC_Count], &
       stridep=[iNC_Stride], &
       vars=rNC_Vars), __FILE__, __LINE__ )

end subroutine nf_get_variable_array_as_vector_float

!----------------------------------------------------------------------

subroutine netcdf_dump_cdl(NCFILE, iLU)

  type (T_NETCDF4_FILE ) :: NCFILE
  type (T_NETCDF_ATTRIBUTE), pointer :: pNC_ATT
  type (T_NETCDF_VARIABLE), pointer :: pNC_VAR
  type (T_NETCDF_DIMENSION), pointer :: pNC_DIM
  integer :: iLU
  character (len=256) :: sBuf, sBuf2
  character (len=256) :: sDimName
  integer (c_int) :: iDimID
  integer (c_int) :: iUbound

  integer :: iResult, iIndex, iIndex2, iIndex3, iIndex4

  sBuf=""; sBuf2=""

  write(unit=iLU, fmt="(a)") "netcdf "//trim(NCFILE%sFilename)//" {"
  write(unit=iLU, fmt="(a)") "  dimensions:"

  do iIndex = 0, NCFILE%iNumberOfDimensions - 1
    write(unit=iLU, fmt="(4x,a, ' = ', i0, ';')") trim(NCFILE%pNC_DIM(iIndex)%sDimensionName), &
      NCFILE%pNC_DIM(iIndex)%iNC_DimSize
  enddo

  do iIndex = 0, NCFILE%iNumberOfVariables - 1

    pNC_VAR => NCFILE%pNC_VAR(iIndex)

    if(pNC_VAR%iNumberOfDimensions > 0) then

      sBuf = ' ('

      iUbound = pNC_VAR%iNumberOfDimensions - 1
      do iIndex3 = 0, iUbound

        iDimID = pNC_VAR%iNC_DimID(iIndex3)

        call assert(iDimID >=0 .and. &
          iDimID <= ubound( NCFILE%pNC_DIM, 1 ), &
          "INTERNAL PROGRAMMING ERROR -- iDimID out of bounds", &
          __FILE__, __LINE__)

        pNC_DIM => NCFILE%pNC_DIM(iDimID)
        sDimName = pNC_DIM%sDimensionName

        write(sBuf2, fmt="(i12)") pNC_DIM%iNC_DimSize
        sBuf = trim(sBuf)//trim(pNC_DIM%sDimensionName)//"=" &
           //trim(adjustl(sBuf2))

        if (iIndex3 /= iUbound) sBuf = trim(sBuf)//", "

      enddo

      sBuf = trim(sBuf)//')'

    else

      sBuf = ""

    endif

    sBuf = trim(NETCDF_DATA_TYPE(pNC_VAR%iNC_VarType)) &
       //" "//trim(pNC_VAR%sVariableName)//sBuf//";"

    write(unit=iLU, fmt="(2x,a)") trim(sBuf)

    iUbound = pNC_VAR%iNumberOfAttributes - 1
    do iIndex3 = 0, iUbound

      pNC_ATT => NCFILE%pNC_VAR(iIndex)%pNC_ATT(iIndex3)

      sBuf = trim(pNC_VAR%sVariableName)//":"//trim(pNC_ATT%sAttributeName )//" ="

      do iIndex4=0, ubound(pNC_ATT%sAttValue, 1)

          sBuf = trim(sBuf)//" "//trim(pNC_ATT%sAttValue(iIndex4))

      enddo

      sBuf=trim(sBuf)//"; // "//trim(NETCDF_DATA_TYPE(pNC_ATT%iNC_AttType) )

      write(unit=iLU, fmt="(4x,a)") trim(sBuf)

    enddo

  enddo

  do iIndex = 0, NCFILE%iNumberOfAttributes - 1

    pNC_ATT => NCFILE%pNC_ATT(iIndex)

    sBuf = ":"//trim(pNC_ATT%sAttributeName )//" ="

    do iIndex4=0, ubound(pNC_ATT%sAttValue, 1)

        sBuf = trim(sBuf)//" "//trim(pNC_ATT%sAttValue(iIndex4))

    enddo

    sBuf=trim(sBuf)//"; // "//trim(NETCDF_DATA_TYPE(pNC_ATT%iNC_AttType) )

    write(unit=iLU, fmt="(a)") trim(sBuf)

  enddo

  write(unit=iLU, fmt="(a,/,/)") "}"


end subroutine netcdf_dump_cdl

!----------------------------------------------------------------------

function nf_get_first_and_last(NCFILE, iVarIndex)  result(dpValues)

  type (T_NETCDF4_FILE ) :: NCFILE
  integer (c_int) :: iVarIndex
  real (c_double), dimension(0:1) :: dpValues

  ! [ LOCALS ]
  type (T_NETCDF_VARIABLE), pointer :: pNC_VAR
  type (T_NETCDF_DIMENSION), pointer :: pNC_DIM
  integer (c_int) :: iDimSize
  integer (c_int) :: iDimIndex
  integer (c_size_t) :: iStride
  integer (c_size_t) :: iCount
  integer (c_short), dimension(0:1) :: spValues
  integer (c_int), dimension(0:1) :: ipValues
  real (c_float), dimension(0:1) :: rpValues

  call assert (iVarIndex >= lbound(NCFILE%pNC_VAR,1) &
    .and. iVarIndex <= ubound(NCFILE%pNC_VAR,1), &
      "INTERNAL PROGRAMMING ERROR - index out of bounds NC_FILE%pNC_VAR" &
      //"~Offending index value: "//trim(asCharacter(iVarIndex)), &
      __FILE__, __LINE__)

  pNC_VAR => NCFILE%pNC_VAR(iVarIndex)
  iDimSize = nf_return_DimSize(NCFILE, pNC_VAR%iNC_DimID(0) )

  if (iDimSize > 1) then
    iCount = 2_c_size_t
    iStride = int(iDimSize, c_size_t) - 1_c_size_t
  else
    iCount = 1_c_size_t
    iStride = 1_c_size_t
  endif

  select case (pNC_VAR%iNC_VarType )

    case (NC_SHORT)

      call nf_get_variable_vector_short(NCFILE=NCFILE, &
        iNC_VarID=pNC_VAR%iNC_VarID, &
        iNC_Start=0_c_size_t, &
        iNC_Count=iCount, &
        iNC_Stride=iStride, &
        iNC_Vars=spValues)

      dpValues = real(spValues, c_double)

    case (NC_INT)

      call nf_get_variable_vector_int(NCFILE=NCFILE, &
        iNC_VarID=pNC_VAR%iNC_VarID, &
        iNC_Start=0_c_size_t, &
        iNC_Count=iCount, &
        iNC_Stride=iStride, &
        iNC_Vars=ipValues)

      dpValues = real(ipValues, c_double)

    case (NC_FLOAT)

      call nf_get_variable_vector_float(NCFILE=NCFILE, &
        iNC_VarID=pNC_VAR%iNC_VarID, &
        iNC_Start=0_c_size_t, &
        iNC_Count=iCount, &
        iNC_Stride=iStride, &
        rNC_Vars=rpValues)

      dpValues = real(rpValues, c_double)

    case (NC_DOUBLE)

      call nf_get_variable_vector_double(NCFILE=NCFILE, &
        iNC_VarID=pNC_VAR%iNC_VarID, &
        iNC_Start=0_c_size_t, &
        iNC_Count=iCount, &
        iNC_Stride=iStride, &
        dpNC_Vars=dpValues)

    case default

      call warn("INTERNAL PROGRAMMING ERROR: Unhandled select case. Program will probably fail.", __FILE__, __LINE__)

  end select

  !> if there is only one day of data in this netCDF file, the
  !> first day equals the last day
  if (iCount == 1) dpValues(NC_LAST) = dpValues(NC_FIRST)

end function nf_get_first_and_last

!----------------------------------------------------------------------

subroutine nf_calculate_time_range(NCFILE)

  type (T_NETCDF4_FILE), intent(inout) :: NCFILE

  NCFILE%iOriginJD = julian_day(NCFILE%iOriginYear, &
    NCFILE%iOriginMonth, NCFILE%iOriginDay)

  NCFILE%iFirstDayJD = NCFILE%iOriginJD + NCFILE%dpFirstAndLastTimeValues(NC_FIRST)
  NCFILE%iLastDayJD = NCFILE%iOriginJD + NCFILE%dpFirstAndLastTimeValues(NC_LAST)

end subroutine nf_calculate_time_range

!----------------------------------------------------------------------

subroutine nf_get_time_units(NCFILE)

  type (T_NETCDF4_FILE), intent(inout) :: NCFILE

  ! [ LOCALS ]
  type (T_NETCDF_VARIABLE), pointer :: pNC_VAR
  character (len=256)   :: sDateTime
  character (len=256)   :: sItem
  integer (c_int)  :: iIndex
  logical (c_bool) :: lFound
  integer (c_int)  :: iStat
  real (c_float)   :: fTempVal

  call assert(NCFILE%iVarID(NC_TIME) >= 0, "INTERNAL PROGRAMMING ERROR -- " &
    //"nf_get_time_units must be called only after a call is made to ~" &
    //"netcdf_get_variable_ids", __FILE__, __LINE__)

  pNC_VAR => NCFILE%pNC_VAR(NCFILE%iVarID(NC_TIME) )

  lFound = FALSE

  do iIndex=0, pNC_VAR%iNumberOfAttributes - 1

    if ( pNC_VAR%pNC_ATT(iIndex)%sAttributeName .strequal. "units"   ) then
      lFound = TRUE
      exit
    endif

  enddo

  call assert (lFound, "Failed to find the 'units' attribute associated " &
    //"with time variable "//dquote(pNC_VAR%sVariableName), &
    __FILE__, __LINE__)

  sDateTime = pNC_VAR%pNC_ATT(iIndex)%sAttValue(0)

  call chomp(sDateTime, sItem)    ! should be "days"
  call chomp(sDateTime, sItem)    ! should be "since"

  call chomp(sDateTime, sItem, "/-")
  read(sItem, *) NCFILE%iOriginYear

  call chomp(sDateTime, sItem, "/-")
  read(sItem, *) NCFILE%iOriginMonth

  !> @todo this does not appear to have the fix that was applied to the master swb branch to
  !!       deal with cases where no time values are given at all

  read(sDateTime, *) NCFILE%iOriginDay

  call chomp(sDateTime, sItem, ":")
  read(sItem, *, iostat=iStat) NCFILE%iOriginHH
  if (iStat /=0) NCFILE%iOriginHH = 0

  call chomp(sDateTime, sItem, ":")
  read(sItem, *, iostat=iStat) NCFILE%iOriginMM
  if (iStat /=0) NCFILE%iOriginMM = 0

  ! changed this to a real value, since some data providers encode the date and
  ! time as YYYY-MM-DD HH-MM-SS.S
  read(sDateTime, *, iostat=iStat) fTempVal
  if (iStat ==0) then
    NCFILE%iOriginSS = int(fTempVal, c_int)
  else
    NCFILE%iOriginSS = 0
  endif

end subroutine nf_get_time_units

!----------------------------------------------------------------------

subroutine nf_get_xyz_units(NCFILE)

  type (T_NETCDF4_FILE), intent(inout) :: NCFILE

  ! [ LOCALS ]
  type (T_NETCDF_VARIABLE), pointer :: pNC_VAR
  integer (c_int) :: iIndex, iIndex2
  logical (c_bool) :: lFound
  integer (c_int) :: iStat

  do iIndex = NC_Y, NC_Z

    call assert(NCFILE%iVarID(iIndex) >= 0, "INTERNAL PROGRAMMING ERROR -- " &
    //"nc_get_XYZ_units must be called only after a call is made to ~" &
    //"netcdf_get_variable_ids", __FILE__, __LINE__)

    pNC_VAR => NCFILE%pNC_VAR(NCFILE%iVarID(iIndex) )

    lFound = FALSE

    do iIndex2=0, pNC_VAR%iNumberOfAttributes - 1

      if ( pNC_VAR%pNC_ATT(iIndex2)%sAttributeName .strequal. "units" ) then
        lFound = TRUE
        exit
      endif

    enddo

    if (lFound) then
      NCFILE%sVarUnits(iIndex) = trim(pNC_VAR%pNC_ATT(iIndex2)%sAttValue(0))
    endif

  enddo

end subroutine nf_get_xyz_units

!----------------------------------------------------------------------

subroutine nf_get_scale_and_offset(NCFILE)

  type (T_NETCDF4_FILE), intent(inout) :: NCFILE

  ! [ LOCALS ]
  type (T_NETCDF_VARIABLE), pointer :: pNC_VAR
  integer (c_int) :: iIndex
  logical (c_bool) :: lFound
  integer (c_int) :: iStat
  character (len=32) :: sBuf

  pNC_VAR => NCFILE%pNC_VAR(NCFILE%iVarID(NC_Z) )

  lFound = FALSE

  do iIndex=0, pNC_VAR%iNumberOfAttributes - 1

    if ( pNC_VAR%pNC_ATT(iIndex)%sAttributeName .strequal. "scale_factor" ) then
      lFound = TRUE
      exit
    endif

  enddo

  if (lFound) then
    if (allocated( pNC_VAR%pNC_ATT(iIndex)%i2AttValue )) then
      NCFILE%rScaleFactor(NC_Z) = asFloat( pNC_VAR%pNC_ATT(iIndex)%i2AttValue(0) )
    elseif (allocated( pNC_VAR%pNC_ATT(iIndex)%iAttValue )) then
      NCFILE%rScaleFactor(NC_Z) = asFloat( pNC_VAR%pNC_ATT(iIndex)%iAttValue(0) )
    elseif (allocated( pNC_VAR%pNC_ATT(iIndex)%rAttValue )) then
      NCFILE%rScaleFactor(NC_Z) = pNC_VAR%pNC_ATT(iIndex)%rAttValue(0)
    elseif (allocated( pNC_VAR%pNC_ATT(iIndex)%dpAttValue )) then
      NCFILE%rScaleFactor(NC_Z) = asFloat( pNC_VAR%pNC_ATT(iIndex)%dpAttValue(0) )
    elseif (len_trim(pNC_VAR%pNC_ATT(iIndex)%sAttValue(0)) > 0) then
      sBuf = trim(pNC_VAR%pNC_ATT(iIndex)%sAttValue(0) )
      read(sBuf,*) NCFILE%rScaleFactor(NC_Z)
    else
      call die("Error reading the 'scale_factor' attribute from the netCDF file" &
        //dQuote(NCFILE%sFilename))
    endif
  endif

  !> Now repeat the process for "add_offset" attribute
  lFound = FALSE

  do iIndex=0, pNC_VAR%iNumberOfAttributes - 1

    if ( pNC_VAR%pNC_ATT(iIndex)%sAttributeName .strequal. "add_offset" ) then
      lFound = TRUE
      exit
    endif

  enddo

  if (lFound) then
    if (allocated( pNC_VAR%pNC_ATT(iIndex)%i2AttValue )) then
      NCFILE%rAddOffset(NC_Z) = asFloat( pNC_VAR%pNC_ATT(iIndex)%i2AttValue(0) )
    elseif (allocated( pNC_VAR%pNC_ATT(iIndex)%iAttValue )) then
      NCFILE%rAddOffset(NC_Z) = asFloat( pNC_VAR%pNC_ATT(iIndex)%iAttValue(0) )
    elseif (allocated( pNC_VAR%pNC_ATT(iIndex)%rAttValue )) then
      NCFILE%rAddOffset(NC_Z) = pNC_VAR%pNC_ATT(iIndex)%rAttValue(0)
    elseif (allocated( pNC_VAR%pNC_ATT(iIndex)%dpAttValue )) then
      NCFILE%rAddOffset(NC_Z) = asFloat( pNC_VAR%pNC_ATT(iIndex)%dpAttValue(0) )
    elseif (len_trim(pNC_VAR%pNC_ATT(iIndex)%sAttValue(0)) > 0) then
      sBuf = trim(pNC_VAR%pNC_ATT(iIndex)%sAttValue(0) )
      read(sBuf,*) NCFILE%rAddOffset(NC_Z)
    else
      call die("Error reading the 'add_offset' attribute from the netCDF file" &
        //dQuote(NCFILE%sFilename))
    endif
  endif

end subroutine nf_get_scale_and_offset

!----------------------------------------------------------------------

subroutine nf_get_variable_id_and_type( NCFILE, strict_asserts )
  type (T_NETCDF4_FILE), intent(inout)          :: NCFILE
  logical (c_bool), intent(in), optional   :: strict_asserts

  ! [ LOCALS ]
  integer (c_int)              :: iIndex
  type (T_NETCDF_VARIABLE), pointer :: pNC_VAR
  logical (c_bool)             :: strict_asserts_l

  if ( present( strict_asserts ) ) then
    strict_asserts_l = strict_asserts
  else
    strict_asserts_l = TRUE
  endif

  NCFILE%iVarID = -9999

  do iIndex=0, NCFILE%iNumberOfVariables - 1

    pNC_VAR => NCFILE%pNC_VAR(iIndex)

    if ( pNC_VAR%sVariableName .strequal. NCFILE%sVarName(NC_X)  ) then
     NCFILE%iVarIndex(NC_X) = iIndex
     NCFILE%iVarID(NC_X) = pNC_VAR%iNC_VarID
     NCFILE%iVarType(NC_X) = pNC_VAR%iNC_VarType
     NCFILE%iVar_DimID(NC_X,:) = pNC_VAR%iNC_DimID

    elseif ( pNC_VAR%sVariableName .strequal. NCFILE%sVarName(NC_Y) ) then
     NCFILE%iVarIndex(NC_Y) = iIndex
     NCFILE%iVarID(NC_Y) = pNC_VAR%iNC_VarID
     NCFILE%iVarType(NC_Y) = pNC_VAR%iNC_VarType
     NCFILE%iVar_DimID(NC_Y,:) = pNC_VAR%iNC_DimID

   elseif ( pNC_VAR%sVariableName .strequal. NCFILE%sVarName(NC_Z) ) then
     NCFILE%iVarIndex(NC_Z) = iIndex
     NCFILE%iVarID(NC_Z) = pNC_VAR%iNC_VarID
     NCFILE%iVarType(NC_Z) = pNC_VAR%iNC_VarType
     NCFILE%iVar_DimID(NC_Z,:) = pNC_VAR%iNC_DimID

    elseif ( pNC_VAR%sVariableName .strequal. NCFILE%sVarName(NC_TIME) ) then
     NCFILE%iVarIndex(NC_TIME) = iIndex
     NCFILE%iVarID(NC_TIME) = pNC_VAR%iNC_VarID
     NCFILE%iVarType(NC_TIME) = pNC_VAR%iNC_VarType
     NCFILE%iVar_DimID(NC_TIME,:) = pNC_VAR%iNC_DimID
    endif

  enddo

  if ( strict_asserts_l ) then

    call assert(NCFILE%iVarID(NC_X) >= 0, &
     "Unable to find the variable named "//dquote(NCFILE%sVarName(NC_X) )//" in " &
     //"file "//dquote(NCFILE%sFilename), __FILE__, __LINE__)

    call assert(NCFILE%iVarID(NC_Y) >= 0, &
     "Unable to find the variable named "//dquote(NCFILE%sVarName(NC_Y))//" in " &
     //"file "//dquote(NCFILE%sFilename), __FILE__, __LINE__)

    call assert(NCFILE%iVarID(NC_Z) >= 0, &
     "Unable to find the variable named "//dquote(NCFILE%sVarName(NC_Z))//" in " &
     //"file "//dquote(NCFILE%sFilename), __FILE__, __LINE__)

    if ( NCFILE%iVarID(NC_TIME) < 0 )  &
     call warn("Unable to find the variable named "//dquote(NCFILE%sVarName(NC_TIME))//" in " &
       //"file "//dquote(NCFILE%sFilename) )

  endif

end subroutine nf_get_variable_id_and_type

!----------------------------------------------------------------------

function nf_return_index_double(rValues, rTargetValue, rOffsetValue)  result(iIndex)

  real (c_double), dimension(:) :: rValues
  real (c_double) :: rTargetValue
  real (c_double) :: rOffsetValue
  integer (c_int) :: iIndex

  ! [ LOCALS ]
  integer (c_int) :: iCount
  real (c_double) :: rDiff, rDiffMin

  ! attempting to account for the fact that coordinates are specified
  ! initially relative toi cell edges, but are stored internally within netCDF
  ! relative to cell centers
  if ( .not. (rTargetValue >= (minval(rValues) - rOffsetValue) )             &
         .and. (rTargetValue <= (maxval(rValues) + rOffsetValue) ) ) then
    call LOGS%write("rTargetValue (" &
    //trim(asCharacter(rTargetValue))//") is not within the range " &
    //trim(asCharacter(minval(rValues)))//" to "//trim(asCharacter(maxval(rValues))), lEcho=TRUE )

    call assert(FALSE, "INTERNAL PROGRAMMING ERROR", __FILE__, __LINE__)
  endif

  rDiffMin = 1.e+20

  do iCount=lbound(rValues,1), ubound(rValues,1)

    rDiff = abs(rValues(iCount) - rTargetValue)

    if ( rDiff < rDiffMin ) then
      iIndex = iCount
      rDiffMin =rDiff
    endif

  enddo

!  print *, trim(__FILE__), ": ", __LINE__
!  print *, "index: ", iIndex, "  value: ", rValues(iIndex),           &
!           "  target value: ", rTargetValue

end function nf_return_index_double

!----------------------------------------------------------------------

function netcdf_coord_to_col_row(NCFILE, rX, rY)  result(iColRow)

  type (T_NETCDF4_FILE ) :: NCFILE
  real (c_double) :: rX
  real (c_double) :: rY
  integer (c_size_t), dimension(2) :: iColRow

  ! [ LOCALS ]
  integer (c_int) :: iColNum, iRowNum
  real (c_double) :: x_offset
  real (c_double) :: y_offset

  x_offset = NCFILE%rGridCellSizeX / 2.0_c_double + NCFILE%rCoordinateTolerance
  y_offset = NCFILE%rGridCellSizeY / 2.0_c_double + NCFILE%rCoordinateTolerance

  call assert( allocated( NCFILE%rX_Coords ), "Internal programming error -- attempt " &
  //"to access unallocated array rX_Coords.", __FILE__, __LINE__ )

  if (rX < (minval(NCFILE%rX_Coords) - x_offset) ) &
    call die( "X coordinate value "//asCharacter(rX)//" is less than the minimum X coordinate " &
      //"value ("//asCharacter(minval(NCFILE%rX_Coords)-x_offset)//") contained in the netCDF file " &
      //dquote(NCFILE%sFilename), trim(__FILE__), __LINE__ )

  if (rX > (maxval(NCFILE%rX_Coords) + x_offset) ) &
    call die( "X coordinate value "//asCharacter(rX)//" is greater than the maximum X coordinate " &
      //"value ("//asCharacter(maxval(NCFILE%rX_Coords)+x_offset)//") contained in the netCDF file " &
      //dquote(NCFILE%sFilename), trim(__FILE__), __LINE__  )

  if (rY < (minval(NCFILE%rY_Coords) - y_offset) ) &
    call die( "Y coordinate value "//asCharacter(rY)//" is less than the minimum Y coordinate " &
      //"value ("//asCharacter(minval(NCFILE%rY_Coords)-y_offset)//") contained in the netCDF file " &
      //dquote(NCFILE%sFilename), trim(__FILE__), __LINE__  )

  if (rY > (maxval(NCFILE%rY_Coords) + y_offset) ) &
    call die( "Y coordinate value "//asCharacter(rY)//" is greater than the maximum Y coordinate " &
      //"value ("//asCharacter(maxval(NCFILE%rY_Coords)+y_offset)//") contained in the netCDF file " &
      //dquote(NCFILE%sFilename), trim(__FILE__), __LINE__  )

  iColNum = nf_return_index_double(NCFILE%rX_Coords, rX, x_offset)
  iRowNum = nf_return_index_double(NCFILE%rY_Coords, rY, y_offset)

  iColRow(COLUMN) = iColNum
  iColRow(ROW) = iRowNum

end function netcdf_coord_to_col_row

!----------------------------------------------------------------------

function nf_get_varid(NCFILE, sVariableName)  result(iNC_VarID)

  type (T_NETCDF4_FILE ) :: NCFILE
  character (len=*) :: sVariableName
  integer (c_int) :: iNC_VarID

  integer (c_int) :: iIndex
  type (T_NETCDF_VARIABLE), pointer :: pNC_VAR

  iNC_VarID = -9999

  do iIndex=0, NCFILE%iNumberOfVariables - 1

    pNC_VAR => NCFILE%pNC_VAR(iIndex)

    if(trim(sVariableName) .eq. trim(pNC_VAR%sVariableName) ) then

      iNC_VarID = iIndex
      exit

    endif

  enddo

end function nf_get_varid

!----------------------------------------------------------------------

subroutine nf_create(NCFILE, sFilename, iLU)

  type (T_NETCDF4_FILE ) :: NCFILE
  character (len=*) :: sFilename
  integer (c_int), optional :: iLU

   call nf_trap(nc_create(path=trim(fortran_to_c_string(sFilename)), &
                  cmode=NC_NETCDF4, &
                  ncidp=NCFILE%iNCID), &
                  __FILE__, __LINE__)

!
! had read somewhere that the interface:
! character (c_char)   :: varname(*)
!
! would properly pass fortran string to c; however,
! this does not appear ot be the case.
!

!   call nf_trap(nc_create(path=trim(sFilename), &
!                  cmode=NC_NETCDF4, &
!                  ncidp=NCFILE%iNCID), &
!                  __FILE__, __LINE__)


  NCFILE%sFilename = trim(sFilename)
  NCFILE%iFileFormat = NC_FORMAT_NETCDF4

  if (present(iLU) ) then
    call LOGS%write("Created netCDF file for output. Filename: " &
      //dquote(NCFILE%sFilename)//"; NCID="//trim(asCharacter(NCFILE%iNCID) ) )
  endif

end subroutine nf_create

!----------------------------------------------------------------------

subroutine nf_define_deflate(NCFILE, iVarID, iShuffle, iDeflate, iDeflate_level)

  type (T_NETCDF4_FILE ) :: NCFILE
  integer (c_int) :: iVarID
  integer (c_int) :: iShuffle
  integer (c_int) :: iDeflate
  integer (c_int) :: iDeflate_level

  call nf_trap(nc_def_var_deflate(ncid=NCFILE%iNCID, &
          varid=iVarID, &
          shuffle=iShuffle, &
          deflate=iDeflate, &
          deflate_level=iDeflate_level), &
          __FILE__, __LINE__)

end subroutine nf_define_deflate

!----------------------------------------------------------------------

subroutine nf_enddef(NCFILE)

  type (T_NETCDF4_FILE ) :: NCFILE

  call nf_trap(nc_enddef(ncid=NCFILE%iNCID), &
       __FILE__, __LINE__)

end subroutine nf_enddef

!----------------------------------------------------------------------

subroutine nf_redef(NCFILE)

  type (T_NETCDF4_FILE ) :: NCFILE

  call nf_trap(nc_redef(ncid=NCFILE%iNCID), &
       __FILE__, __LINE__)

end subroutine nf_redef

!----------------------------------------------------------------------

subroutine nf_define_dimension(NCFILE, sDimensionName, iDimensionSize)

  type (T_NETCDF4_FILE ) :: NCFILE
  character (len=*) :: sDimensionName
  integer (c_int) :: iDimensionSize
  integer (c_int) :: iDimID

  integer (c_size_t) :: iDimSize
  type (T_NETCDF_DIMENSION), pointer :: pNC_DIM

  iDimSize = int(iDimensionSize, c_size_t)

  call nf_trap(nc_def_dim(ncid=NCFILE%iNCID, &
                          name=trim(sDimensionName)//c_null_char, &
                          lenv=iDimSize, &
                          dimidp=iDimID), &
                          __FILE__, __LINE__)

end subroutine nf_define_dimension

!----------------------------------------------------------------------

subroutine nf_delete_attribute(NCFILE, sVariableName, sAttributeName)

  type (T_NETCDF4_FILE ) :: NCFILE
  character (len=*)      :: sVariableName
  character (len=*)      :: sAttributeName

  integer (c_int) :: iVarID

  iVarID = nf_get_varid(NCFILE, sVariableName//c_null_char)

  call nf_trap(nc_del_att(ncid=NCFILE%iNCID,                       &
                          varid=iVarID,                            &
                          name=trim(sAttributeName)//c_null_char), &
                          __FILE__, __LINE__)

end subroutine nf_delete_attribute

!----------------------------------------------------------------------

subroutine nf_define_dimensions( NCFILE )

  type (T_NETCDF4_FILE) :: NCFILE

  ! [ LOCALS ]
  integer (c_int) :: iStat
  integer (c_int) :: iIndex
  character (len=256) :: sDimName
  type (T_NETCDF_DIMENSION), pointer :: pNC_DIM

  do iIndex = 0, NCFILE%iNumberOfDimensions-1

    pNC_DIM => NCFILE%pNC_DIM(iIndex)

    call nf_trap(nc_def_dim(ncid=NCFILE%iNCID, &
      name=trim(pNC_DIM%sDimensionName)//c_null_char, &
      lenv=pNC_DIM%iNC_DimSize, &
      dimidp=pNC_DIM%iNC_DimID), &
      __FILE__, __LINE__ )

  enddo

end subroutine nf_define_dimensions

!----------------------------------------------------------------------

subroutine nf_set_standard_dimensions(NCFILE, iNX, iNY, write_time_bounds )

  type (T_NETCDF4_FILE )           :: NCFILE
  integer (c_int)             :: iNX
  integer (c_int)             :: iNY
  logical (c_bool), optional  :: write_time_bounds

  ! [ LOCALS ]
  integer (c_int)   :: iStat
  logical (c_bool)  :: write_time_bounds_l

  iStat = 0

  NCFILE%iNumberOfDimensions = 3

  if ( present( write_time_bounds ) ) then

    write_time_bounds_l = write_time_bounds

  else

    write_time_bounds_l = FALSE

  endif

  if ( write_time_bounds_l ) NCFILE%iNumberOfDimensions = 4

  if (associated(NCFILE%pNC_DIM) ) deallocate(NCFILE%pNC_DIM, stat=iStat)
  call assert(iStat == 0, "Could not deallocate memory for NC_DIM member in NC_FILE defined type", &
    __FILE__, __LINE__)

  allocate(NCFILE%pNC_DIM( 0 : NCFILE%iNumberOfDimensions-1), stat=iStat )
  call assert(iStat == 0, "Could not allocate memory for NC_DIM member in NC_FILE defined type", &
    __FILE__, __LINE__)

  !> define the time dimension;
  NCFILE%pNC_DIM(NC_TIME)%sDimensionName = "time"
  NCFILE%pNC_DIM(NC_TIME)%iNC_DimSize = NC_UNLIMITED

  !> define the y dimension;
  NCFILE%pNC_DIM(NC_Y)%sDimensionName = "y"
  NCFILE%pNC_DIM(NC_Y)%iNC_DimSize = iNY

  !> define the x dimension;
  NCFILE%pNC_DIM(NC_X)%sDimensionName = "x"
  NCFILE%pNC_DIM(NC_X)%iNC_DimSize = iNX

  if ( write_time_bounds_l ) then
    !> define the auxiliary dimension;
    NCFILE%pNC_DIM(NC_AUX)%sDimensionName = "nv"
    NCFILE%pNC_DIM(NC_AUX)%iNC_DimSize = 2
  endif

end subroutine nf_set_standard_dimensions

!----------------------------------------------------------------------

subroutine nf_set_standard_variables(NCFILE, sVarName_z, lLatLon, write_time_bounds )

  type (T_NETCDF4_FILE )            :: NCFILE
  character (len=*)                 :: sVarName_z
  logical (c_bool), optional   :: lLatLon
  logical (c_bool), optional   :: write_time_bounds

  ! [ LOCALS ]
  integer (c_int) :: iStat
  logical (c_bool) :: lLatLon_l
  logical (c_bool) :: write_time_bounds_l

  if (present( lLatLon) ) then
    lLatLon_l = lLatLon
  else
    lLatLon_l = FALSE
  endif

  if (present(write_time_bounds) ) then
    write_time_bounds_l = write_time_bounds
  else
    write_time_bounds_l = FALSE
  endif

  iStat = 0

  NCFILE%iNumberOfVariables = 5

  if ( lLatLon_l ) NCFILE%iNumberOfVariables = 7
  if ( write_time_bounds_l )  NCFILE%iNumberOfVariables =                       &
                               NCFILE%iNumberOfVariables + 1

  ! reset the ID for TIME BNDS to the last varid
  NC_TIME_BNDS = NCFILE%iNumberOfVariables - 1

  if (associated(NCFILE%pNC_VAR) ) deallocate(NCFILE%pNC_VAR, stat=iStat)
  call assert(iStat == 0, "Could not deallocate memory for NC_VAR member in NC_FILE defined type", &
    __FILE__, __LINE__)

  allocate(NCFILE%pNC_VAR( 0 : NCFILE%iNumberOfVariables-1), stat=iStat )
  call assert(iStat == 0, "Could not allocate memory for NC_VAR member in NC_FILE defined type", &
    __FILE__, __LINE__)

  NCFILE%pNC_VAR(NC_TIME)%sVariableName = "time"
  NCFILE%pNC_VAR(NC_TIME)%iNC_VarType = NC_FLOAT
  NCFILE%pNC_VAR(NC_TIME)%iNumberOfDimensions = 1
  NCFILE%pNC_VAR(NC_TIME)%iNC_DimID(0) = NCFILE%pNC_DIM(NC_TIME)%iNC_DimID

  NCFILE%pNC_VAR(NC_Y)%sVariableName = "y"
  NCFILE%pNC_VAR(NC_Y)%iNC_VarType = NC_DOUBLE
  NCFILE%pNC_VAR(NC_Y)%iNumberOfDimensions = 1
  NCFILE%pNC_VAR(NC_Y)%iNC_DimID = NCFILE%pNC_DIM(NC_Y)%iNC_DimID

  NCFILE%pNC_VAR(NC_X)%sVariableName = "x"
  NCFILE%pNC_VAR(NC_X)%iNC_VarType = NC_DOUBLE
  NCFILE%pNC_VAR(NC_X)%iNumberOfDimensions = 1
  NCFILE%pNC_VAR(NC_X)%iNC_DimID = NCFILE%pNC_DIM(NC_X)%iNC_DimID

  NCFILE%pNC_VAR(NC_CRS)%sVariableName = "crs"
  NCFILE%pNC_VAR(NC_CRS)%iNC_VarType = NC_INT
  NCFILE%pNC_VAR(NC_CRS)%iNumberOfDimensions = 0

  NCFILE%pNC_VAR(NC_Z)%sVariableName = trim(sVarName_z)
  NCFILE%pNC_VAR(NC_Z)%iNC_VarType = NC_FLOAT
  NCFILE%pNC_VAR(NC_Z)%iNumberOfDimensions = 3
  NCFILE%pNC_VAR(NC_Z)%iNC_DimID = [NCFILE%pNC_DIM(NC_TIME)%iNC_DimID, &
                                 NCFILE%pNC_DIM(NC_Y)%iNC_DimID, &
                                 NCFILE%pNC_DIM(NC_X)%iNC_DimID,0]

  NCFILE%sVarName(NC_Z) = trim(sVarName_z)

  if ( lLatLon_l ) then

    NCFILE%pNC_VAR(NC_LAT)%sVariableName = "lat"
    NCFILE%pNC_VAR(NC_LAT)%iNC_VarType = NC_DOUBLE
    NCFILE%pNC_VAR(NC_LAT)%iNumberOfDimensions = 2
    NCFILE%pNC_VAR(NC_LAT)%iNC_DimID = [NCFILE%pNC_DIM(NC_Y)%iNC_DimID, &
                                        NCFILE%pNC_DIM(NC_X)%iNC_DimID,0,0]

    NCFILE%pNC_VAR(NC_LON)%sVariableName = "lon"
    NCFILE%pNC_VAR(NC_LON)%iNC_VarType = NC_DOUBLE
    NCFILE%pNC_VAR(NC_LON)%iNumberOfDimensions = 2
    NCFILE%pNC_VAR(NC_LON)%iNC_DimID = [NCFILE%pNC_DIM(NC_Y)%iNC_DimID, &
                                        NCFILE%pNC_DIM(NC_X)%iNC_DimID,0,0]
  endif

  if ( write_time_bounds_l ) then

    NCFILE%pNC_VAR(NC_TIME_BNDS)%sVariableName = "time_bnds"
    NCFILE%pNC_VAR(NC_TIME_BNDS)%iNC_VarType = NC_DOUBLE
    NCFILE%pNC_VAR(NC_TIME_BNDS)%iNumberOfDimensions = 2
    NCFILE%pNC_VAR(NC_TIME_BNDS)%iNC_DimID = [NCFILE%pNC_DIM(NC_TIME)%iNC_DimID,       &
                                              NCFILE%pNC_DIM(NC_AUX)%iNC_DimID,0,0]

  endif

end subroutine nf_set_standard_variables

!----------------------------------------------------------------------

subroutine nf_set_global_attributes(NCFILE, sDataType, executable_name, &
                                    history_list, sSourceFile )

  type (T_NETCDF4_FILE ) :: NCFILE
  character (len=*), intent(in) :: sDataType
  character (len=*), intent(in), optional    :: executable_name
  type (FSTRING_LIST_T), intent(in), pointer, optional :: history_list
  character (len=*), intent(in), optional    :: sSourceFile

  ! [ LOCALS ]
  integer (c_int)           :: iStat
  type (DATETIME_T)              :: DT
  character (len=20)             :: sDateTime
  character (len=:), allocatable :: executable_name_l
  type (FSTRING_LIST_T), pointer           :: history_list_l
  integer (c_int)           :: indx, jndx
  integer (c_int)  :: records

  if (present( executable_name) ) then
    executable_name_l = trim( executable_name )
  else
    executable_name_l = "SWB"
  endif

  if ( present( history_list ) ) then
    history_list_l => history_list
    NCFILE%iNumberOfAttributes = 3 + history_list_l%count
  else
    allocate( history_list_l )
    call history_list_l%append(trim(sDateTime)//": Soil-Water-Balance model run started.")
    NCFILE%iNumberOfAttributes = 4
  endif

  call DT%systime()
  sDateTime = DT%prettydatetime()

  allocate( NCFILE%pNC_ATT(0:NCFILE%iNumberOfAttributes-1), stat=iStat)
  call assert(iStat == 0, "Could not allocate memory for NC_ATT member of NC_FILE", &
    __FILE__, __LINE__)

  block

    if (present(sSourceFile) ) then

      NCFILE%pNC_ATT(0)%sAttributeName = "source"
      allocate(NCFILE%pNC_ATT(0)%sAttValue(0:0))
      NCFILE%pNC_ATT(0)%sAttValue(0) = trim(sDataType)//" data from file "//dquote(sSourceFile)
      NCFILE%pNC_ATT(0)%iNC_AttType = NC_CHAR
      NCFILE%pNC_ATT(0)%iNC_AttSize = 1_c_size_t

    else

      NCFILE%pNC_ATT(0)%sAttributeName = "source"
      allocate(NCFILE%pNC_ATT(0)%sAttValue(0:0))
      NCFILE%pNC_ATT(0)%sAttValue(0) = trim(sDataType)//" output from " &
        //executable_name_l//" run "   &
        //"started on "//trim(sDateTime)//"."
      NCFILE%pNC_ATT(0)%iNC_AttType = NC_CHAR
      NCFILE%pNC_ATT(0)%iNC_AttSize = 1_c_size_t

    endif

    NCFILE%pNC_ATT(1)%sAttributeName = "executable_version"
    allocate(NCFILE%pNC_ATT(1)%sAttValue(0:0))
    NCFILE%pNC_ATT(1)%sAttValue(0) = "version "//trim(SWB_VERSION)          &
      //", Git branch: "//trim(GIT_BRANCH_STRING)//", Git commit hash string: "   &
      //trim(GIT_COMMIT_HASH_STRING)//", compiled on: "//trim(COMPILE_DATE)       &
      //" "//trim(COMPILE_TIME)//"."
    NCFILE%pNC_ATT(1)%iNC_AttType = NC_CHAR
    NCFILE%pNC_ATT(1)%iNC_AttSize = 1_c_size_t

    NCFILE%pNC_ATT(2)%sAttributeName = "Conventions"
    allocate(NCFILE%pNC_ATT(2)%sAttValue(0:0))
    NCFILE%pNC_ATT(2)%sAttValue(0) = "CF-1.6"
    NCFILE%pNC_ATT(2)%iNC_AttType = NC_CHAR
    NCFILE%pNC_ATT(2)%iNC_AttSize = 1_c_size_t

    ! special case: history may have meny records
    records = history_list_l%count

    do indx=1, records

      jndx = indx + 2
      NCFILE%pNC_ATT( jndx )%sAttributeName = "history"
      allocate(NCFILE%pNC_ATT(jndx)%sAttValue( 0:0 ) )
      NCFILE%pNC_ATT(jndx)%iNC_AttType = NC_CHAR
      NCFILE%pNC_ATT(jndx)%iNC_AttSize = int( records, c_size_t )
      NCFILE%pNC_ATT(jndx)%sAttValue( 0 ) = trim(history_list_l%get( indx ))//C_NULL_CHAR

    enddo

  end block

end subroutine nf_set_global_attributes

!----------------------------------------------------------------------

subroutine nf_set_standard_attributes(NCFILE, sOriginText, PROJ4_string,    &
                                      lLatLon, fValidMin, fValidMax,        &
                                      write_time_bounds )

  type (T_NETCDF4_FILE )             :: NCFILE
  character (len=*)                  :: sOriginText
  character (len=*), optional        :: PROJ4_string
  logical (c_bool), optional    :: lLatLon
  real (c_float), optional      :: fValidMin
  real (c_float), optional      :: fValidMax
  logical (c_bool), optional    :: write_time_bounds

  ! [ LOCALS ]
  integer (c_int)                             :: iStat
  integer (c_int)                             :: iNumAttributes
  type (T_NETCDF_ATTRIBUTE), dimension(:), pointer :: pNC_ATT
  logical (c_bool)                            :: lLatLon_l
  logical (c_bool)                            :: write_time_bounds_l
  type (FSTRING_LIST_T)                       :: attribute_name_list
  type (FSTRING_LIST_T)                       :: attribute_value_list
  character (len=:), allocatable              :: tempstring
  character (len=:), allocatable              :: value_string
  character (len=:), allocatable              :: value_string1
  character (len=:), allocatable              :: value_string2
  integer (c_int)                             :: indx

  if (present( lLatLon ) ) then
    lLatLon_l = lLatLon
  else
    lLatLon_l = FALSE
  endif

  if ( present( write_time_bounds ) ) then
    write_time_bounds_l = write_time_bounds
  else
    write_time_bounds_l = FALSE
  endif

  if (present( PROJ4_string ) ) then
    call create_attributes_from_proj4_string( PROJ4_string, attribute_name_list,   &
                                              attribute_value_list )

    ! Define attributes for the coordinate reference system (CRS)
    iNumAttributes = attribute_name_list%count + 1

    allocate( NCFILE%pNC_VAR(NC_CRS)%pNC_ATT(0:iNumAttributes-1), stat=iStat)
    call assert(iStat == 0, "Could not allocate memory for NC_ATT member in NC_VAR struct of NC_FILE", &
      __FILE__, __LINE__)
    NCFILE%pNC_VAR(NC_CRS)%iNumberOfAttributes = iNumAttributes

    pNC_ATT => NCFILE%pNC_VAR(NC_CRS)%pNC_ATT

    ! the following block of code parses the PROJ4 string and rips standard
    ! CF attributes from the string
    do indx=0, iNumAttributes-2

      tempstring = attribute_name_list%get( indx + 1 )
      pNC_ATT(indx)%sAttributeName = tempstring

      select case ( tempstring )

        case ( "units" )

          value_string = attribute_value_list%get( indx + 1 )
          NCFILE%sVarUnits(NC_X) = value_string
          NCFILE%sVarUnits(NC_Y) = value_string

          allocate(pNC_ATT(indx)%sAttValue(0:0))
          pNC_ATT(indx)%sAttValue(0) = value_string
          pNC_ATT(indx)%iNC_AttType = NC_CHAR
          pNC_ATT(indx)%iNC_AttSize = 1_c_size_t

        case ( "datum", "spheroid", "grid_mapping_name" )

          allocate(pNC_ATT(indx)%sAttValue(0:0))
          pNC_ATT(indx)%sAttValue(0) = attribute_value_list%get( indx + 1 )
          pNC_ATT(indx)%iNC_AttType = NC_CHAR
          pNC_ATT(indx)%iNC_AttSize = 1_c_size_t

        case ( "standard_parallel" )

          allocate(pNC_ATT(indx)%dpAttValue(0:1))

          value_string = attribute_value_list%get( indx + 1 )
          value_string1 = left(value_string, substring=",")
          value_string2 = right(value_string, substring=",")
          
          call assert(len_trim(value_string1) > 0, "standard_parallel requires valid values for '+lat_1' and '+lat_2'.", &
            sHints="Are '+lat_1' or '+lat_2' missing or out of order in the control file PROJ string?")

          pNC_ATT(indx)%dpAttValue(0) = asDouble( value_string1 )
          pNC_ATT(indx)%dpAttValue(1) = asDouble( value_string2 )
          pNC_ATT(indx)%iNC_AttType = NC_DOUBLE
          pNC_ATT(indx)%iNC_AttSize = 2_c_size_t

        case ( "UTM_zone" )

          allocate(pNC_ATT(indx)%iAttValue(0:0))
          pNC_ATT(indx)%iAttValue(0) = asInt( attribute_value_list%get( indx + 1 ) )
          pNC_ATT(indx)%iNC_AttType = NC_INT
          pNC_ATT(indx)%iNC_AttSize = 1_c_size_t

        case default

          allocate(pNC_ATT(indx)%dpAttValue(0:0))
          pNC_ATT(indx)%dpAttValue(0) = asDouble( attribute_value_list%get( indx + 1 ) )
          pNC_ATT(indx)%iNC_AttType = NC_DOUBLE
          pNC_ATT(indx)%iNC_AttSize = 1_c_size_t

      end select

    enddo

    ! last, store the actual PROJ4 string
    pNC_ATT(indx)%sAttributeName = "proj4_string"
    allocate(pNC_ATT(indx)%sAttValue(0:0))
    pNC_ATT(indx)%sAttValue(0) = PROJ4_string
    pNC_ATT(indx)%iNC_AttType = NC_CHAR
    pNC_ATT(indx)%iNC_AttSize = 1_c_size_t

    call attribute_name_list%clear()
    call attribute_value_list%clear()

  endif

  !! define attributes associated with TIME variable
  iNumAttributes = 3
  if ( write_time_bounds_l ) iNumAttributes=4
  allocate( NCFILE%pNC_VAR(NC_TIME)%pNC_ATT(0:iNumAttributes-1), stat=iStat)
  call assert(iStat == 0, "Could not allocate memory for NC_ATT member in NC_VAR struct of NC_FILE", &
    __FILE__, __LINE__)
  NCFILE%pNC_VAR(NC_TIME)%iNumberOfAttributes = iNumAttributes

  pNC_ATT => NCFILE%pNC_VAR(NC_TIME)%pNC_ATT

  pNC_ATT(0)%sAttributeName = "units"
  allocate(pNC_ATT(0)%sAttValue(0:0))
  pNC_ATT(0)%sAttValue(0) = "days since "//trim(sOriginText)//" 00:00:00"
  pNC_ATT(0)%iNC_AttType = NC_CHAR
  pNC_ATT(0)%iNC_AttSize = 1_c_size_t

  pNC_ATT(1)%sAttributeName = "calendar"
  allocate(pNC_ATT(1)%sAttValue(0:0))
  pNC_ATT(1)%sAttValue(0) = "standard"
  pNC_ATT(1)%iNC_AttType = NC_CHAR
  pNC_ATT(1)%iNC_AttSize = 1_c_size_t

  pNC_ATT(2)%sAttributeName = "long_name"
  allocate(pNC_ATT(2)%sAttValue(0:0))
  pNC_ATT(2)%sAttValue(0) = "time"
  pNC_ATT(2)%iNC_AttType = NC_CHAR
  pNC_ATT(2)%iNC_AttSize = 1_c_size_t

  if ( write_time_bounds_l ) then
    pNC_ATT(3)%sAttributeName = "bounds"
    allocate(pNC_ATT(3)%sAttValue(0:0))
    pNC_ATT(3)%sAttValue(0) = "time_bounds"
    pNC_ATT(3)%iNC_AttType = NC_CHAR
    pNC_ATT(3)%iNC_AttSize = 1_c_size_t
  endif

  if (present( fValidMin ) .and. present( fValidMax) ) then

    iNumAttributes = 7
    allocate( NCFILE%pNC_VAR(NC_Z)%pNC_ATT(0:iNumAttributes-1), stat=iStat)
    call assert(iStat == 0, "Could not allocate memory for NC_ATT member in NC_VAR struct of NC_FILE", &
      __FILE__, __LINE__)
    NCFILE%pNC_VAR(NC_Z)%iNumberOfAttributes = iNumAttributes

    pNC_ATT => NCFILE%pNC_VAR(NC_Z)%pNC_ATT

    pNC_ATT(0)%sAttributeName = "units"
    allocate(pNC_ATT(0)%sAttValue(0:0))
    pNC_ATT(0)%sAttValue(0) = NCFILE%sVarUnits(NC_Z)
    pNC_ATT(0)%iNC_AttType = NC_CHAR
    pNC_ATT(0)%iNC_AttSize = 1_c_size_t

    pNC_ATT(1)%sAttributeName = "valid_min"
    allocate(pNC_ATT(1)%rAttValue(0:0))
    pNC_ATT(1)%rAttValue(0) = fValidMin
    pNC_ATT(1)%iNC_AttType = NC_FLOAT
    pNC_ATT(1)%iNC_AttSize = 1_c_size_t

    pNC_ATT(2)%sAttributeName = "valid_max"
    allocate(pNC_ATT(2)%rAttValue(0:0))
    pNC_ATT(2)%rAttValue(0) = fValidMax
    pNC_ATT(2)%iNC_AttType = NC_FLOAT
    pNC_ATT(2)%iNC_AttSize = 1_c_size_t

    pNC_ATT(3)%sAttributeName = "valid_range"
    allocate(pNC_ATT(3)%rAttValue(0:1))
    pNC_ATT(3)%rAttValue(0) = fValidMin
    pNC_ATT(3)%rAttValue(1) = fValidMax
    pNC_ATT(3)%iNC_AttType = NC_FLOAT
    pNC_ATT(3)%iNC_AttSize = 2_c_size_t

    pNC_ATT(4)%sAttributeName = "_FillValue"
    allocate(pNC_ATT(4)%rAttValue(0:0))
    pNC_ATT(4)%rAttValue(0) = NC_FILL_FLOAT
    pNC_ATT(4)%iNC_AttType = NC_FLOAT
    pNC_ATT(4)%iNC_AttSize = 1_c_size_t

    pNC_ATT(5)%sAttributeName = "coordinates"
    allocate(pNC_ATT(5)%sAttValue(0:0))
!    pNC_ATT(5)%sAttValue(0) = "lat lon"
    pNC_ATT(5)%sAttValue(0) = "crs"
    pNC_ATT(5)%iNC_AttType = NC_CHAR
    pNC_ATT(5)%iNC_AttSize = 1_c_size_t

    pNC_ATT(6)%sAttributeName = "grid_mapping"
    allocate(pNC_ATT(6)%sAttValue(0:0))
    pNC_ATT(6)%sAttValue(0) = "crs"
    pNC_ATT(6)%iNC_AttType = NC_CHAR
    pNC_ATT(6)%iNC_AttSize = 1_c_size_t

  else

    iNumAttributes = 3
    allocate( NCFILE%pNC_VAR(NC_Z)%pNC_ATT(0:iNumAttributes-1), stat=iStat)
    call assert(iStat == 0, "Could not allocate memory for NC_ATT member in NC_VAR struct of NC_FILE", &
      __FILE__, __LINE__)
    NCFILE%pNC_VAR(NC_Z)%iNumberOfAttributes = iNumAttributes

    pNC_ATT => NCFILE%pNC_VAR(NC_Z)%pNC_ATT

    pNC_ATT(0)%sAttributeName = "units"
    allocate(pNC_ATT(0)%sAttValue(0:0))
    pNC_ATT(0)%sAttValue(0) = NCFILE%sVarUnits(NC_Z)
    pNC_ATT(0)%iNC_AttType = NC_CHAR
    pNC_ATT(0)%iNC_AttSize = 1_c_size_t

    pNC_ATT(1)%sAttributeName = "coordinates"
    allocate(pNC_ATT(1)%sAttValue(0:0))
    pNC_ATT(1)%sAttValue(0) = "lat lon"
    pNC_ATT(1)%iNC_AttType = NC_CHAR
    pNC_ATT(1)%iNC_AttSize = 1_c_size_t

    pNC_ATT(2)%sAttributeName = "grid_mapping"
    allocate(pNC_ATT(2)%sAttValue(0:0))
    pNC_ATT(2)%sAttValue(0) = "crs"
    pNC_ATT(2)%iNC_AttType = NC_CHAR
    pNC_ATT(2)%iNC_AttSize = 1_c_size_t

  endif

  iNumAttributes = 3
  allocate( NCFILE%pNC_VAR(NC_Y)%pNC_ATT(0:iNumAttributes-1), stat=iStat)
  call assert(iStat == 0, "Could not allocate memory for NC_ATT member in NC_VAR struct of NC_FILE", &
    __FILE__, __LINE__)
  NCFILE%pNC_VAR(NC_Y)%iNumberOfAttributes = iNumAttributes

  pNC_ATT => NCFILE%pNC_VAR(NC_Y)%pNC_ATT

  block

    pNC_ATT(0)%sAttributeName = "units"
    allocate(pNC_ATT(0)%sAttValue(0:0))
    pNC_ATT(0)%sAttValue(0) = NCFILE%sVarUnits(NC_Y)
    pNC_ATT(0)%iNC_AttType = NC_CHAR
    pNC_ATT(0)%iNC_AttSize = 1_c_size_t

    pNC_ATT(1)%sAttributeName = "long_name"
    allocate(pNC_ATT(1)%sAttValue(0:0))
    pNC_ATT(1)%sAttValue(0) = "y coordinate of projection"
    pNC_ATT(1)%iNC_AttType = NC_CHAR
    pNC_ATT(1)%iNC_AttSize = 1_c_size_t

    pNC_ATT(2)%sAttributeName = "standard_name"
    allocate(pNC_ATT(2)%sAttValue(0:0))
    pNC_ATT(2)%sAttValue(0) = "projection_y_coordinate"
    pNC_ATT(2)%iNC_AttType = NC_CHAR
    pNC_ATT(2)%iNC_AttSize = 1_c_size_t


  end block

  iNumAttributes = 3
  allocate( NCFILE%pNC_VAR(NC_X)%pNC_ATT(0:iNumAttributes-1), stat=iStat)
  call assert(iStat == 0, "Could not allocate memory for NC_ATT member in NC_VAR struct of NC_FILE", &
    __FILE__, __LINE__)
  NCFILE%pNC_VAR(NC_X)%iNumberOfAttributes = iNumAttributes

  pNC_ATT => NCFILE%pNC_VAR(NC_X)%pNC_ATT

  block

    pNC_ATT(0)%sAttributeName = "units"
    allocate(pNC_ATT(0)%sAttValue(0:0))
    pNC_ATT(0)%sAttValue(0) = NCFILE%sVarUnits(NC_X)
    pNC_ATT(0)%iNC_AttType = NC_CHAR
    pNC_ATT(0)%iNC_AttSize = 1_c_size_t

    pNC_ATT(1)%sAttributeName = "long_name"
    allocate(pNC_ATT(1)%sAttValue(0:0))
    pNC_ATT(1)%sAttValue(0) = "x coordinate of projection"
    pNC_ATT(1)%iNC_AttType = NC_CHAR
    pNC_ATT(1)%iNC_AttSize = 1_c_size_t

    pNC_ATT(2)%sAttributeName = "standard_name"
    allocate(pNC_ATT(2)%sAttValue(0:0))
    pNC_ATT(2)%sAttValue(0) = "projection_x_coordinate"
    pNC_ATT(2)%iNC_AttType = NC_CHAR
    pNC_ATT(2)%iNC_AttSize = 1_c_size_t


  end block

  if ( lLatLon_l ) then

    iNumAttributes = 3
    allocate( NCFILE%pNC_VAR(NC_LAT)%pNC_ATT(0:iNumAttributes-1), stat=iStat)
    call assert(iStat == 0, "Could not allocate memory for NC_ATT member in NC_VAR struct of NC_FILE", &
      __FILE__, __LINE__)
    NCFILE%pNC_VAR(NC_LAT)%iNumberOfAttributes = iNumAttributes

    pNC_ATT => NCFILE%pNC_VAR(NC_LAT)%pNC_ATT

    block

      pNC_ATT(0)%sAttributeName = "units"
      allocate(pNC_ATT(0)%sAttValue(0:0))
      pNC_ATT(0)%sAttValue(0) = "degrees_north"
      pNC_ATT(0)%iNC_AttType = NC_CHAR
      pNC_ATT(0)%iNC_AttSize = 1_c_size_t

      pNC_ATT(1)%sAttributeName = "long_name"
      allocate(pNC_ATT(1)%sAttValue(0:0))
      pNC_ATT(1)%sAttValue(0) = "latitude"
      pNC_ATT(1)%iNC_AttType = NC_CHAR
      pNC_ATT(1)%iNC_AttSize = 1_c_size_t

      pNC_ATT(2)%sAttributeName = "standard_name"
      allocate(pNC_ATT(2)%sAttValue(0:0))
      pNC_ATT(2)%sAttValue(0) = "latitude"
      pNC_ATT(2)%iNC_AttType = NC_CHAR
      pNC_ATT(2)%iNC_AttSize = 1_c_size_t


    end block


    iNumAttributes = 3
    allocate( NCFILE%pNC_VAR(NC_LON)%pNC_ATT(0:iNumAttributes-1), stat=iStat)
    call assert(iStat == 0, "Could not allocate memory for NC_ATT member in NC_VAR struct of NC_FILE", &
      __FILE__, __LINE__)
    NCFILE%pNC_VAR(NC_LON)%iNumberOfAttributes = iNumAttributes

    pNC_ATT => NCFILE%pNC_VAR(NC_LON)%pNC_ATT

    block

      pNC_ATT(0)%sAttributeName = "units"
      allocate(pNC_ATT(0)%sAttValue(0:0))
      pNC_ATT(0)%sAttValue(0) = "degrees_east"
      pNC_ATT(0)%iNC_AttType = NC_CHAR
      pNC_ATT(0)%iNC_AttSize = 1_c_size_t

      pNC_ATT(1)%sAttributeName = "long_name"
      allocate(pNC_ATT(1)%sAttValue(0:0))
      pNC_ATT(1)%sAttValue(0) = "longitude"
      pNC_ATT(1)%iNC_AttType = NC_CHAR
      pNC_ATT(1)%iNC_AttSize = 1_c_size_t

      pNC_ATT(2)%sAttributeName = "standard_name"
      allocate(pNC_ATT(2)%sAttValue(0:0))
      pNC_ATT(2)%sAttValue(0) = "longitude"
      pNC_ATT(2)%iNC_AttType = NC_CHAR
      pNC_ATT(2)%iNC_AttSize = 1_c_size_t


    end block

  endif

end subroutine nf_set_standard_attributes

!----------------------------------------------------------------------

subroutine nf_put_x_and_y(NCFILE, dpX, dpY)

  type (T_NETCDF4_FILE) :: NCFILE
  real (c_double), dimension(:) :: dpX
  real (c_double), dimension(:) :: dpY

  ! [ LOCALS ]
  integer (c_size_t) :: iLength
  real (c_double), dimension(:), allocatable :: rX, rY

  iLength = int(size(dpX, 1), c_size_t)

  call netcdf_put_variable_vector(NCFILE=NCFILE, &
                   iVarID=NCFILE%pNC_VAR(NC_X)%iNC_VarID, &
                   iStart=[0_c_size_t], &
                   iCount=[iLength], &
                   iStride=[1_c_size_t], &
                   dpValues=dpX)

  iLength = int(size(dpY, 1), c_size_t)

  call netcdf_put_variable_vector(NCFILE=NCFILE, &
                   iVarID=NCFILE%pNC_VAR(NC_Y)%iNC_VarID, &
                   iStart=[0_c_size_t], &
                   iCount=[iLength], &
                   iStride=[1_c_size_t], &
                   dpValues=dpY)

end subroutine nf_put_x_and_y

!----------------------------------------------------------------------

subroutine nf_put_lat_and_lon(NCFILE, dpLat, dpLon)

  type (T_NETCDF4_FILE) :: NCFILE
  real (c_double), dimension(:,:) :: dpLat
  real (c_double), dimension(:,:) :: dpLon

  ! [ LOCALS ]
  integer (c_size_t) :: iNX, iNY

  iNX = int( size(dpLat, 1), c_size_t)
  iNY = int( size(dpLat, 2), c_size_t)

  call netcdf_put_variable_array(NCFILE=NCFILE, &
                   iVarID=NCFILE%pNC_VAR(NC_LAT)%iNC_VarID, &
                   iStart=[0_c_size_t, 0_c_size_t], &
                   iCount=[ iNY, iNX ], &
                   iStride=[1_c_size_t,1_c_size_t], &
                   dpValues=dpLat)


  call netcdf_put_variable_array(NCFILE=NCFILE, &
                   iVarID=NCFILE%pNC_VAR(NC_LON)%iNC_VarID, &
                   iStart=[0_c_size_t, 0_c_size_t], &
                   iCount=[ iNY, iNX ],&
                   iStride=[1_c_size_t,1_c_size_t], &
                   dpValues=dpLon)

end subroutine nf_put_lat_and_lon

!----------------------------------------------------------------------

function nf_define_variable(NCFILE, sVariableName, iVariableType, &
   iNumberOfDimensions, iDimIDs)    result(iVarID)

  type (T_NETCDF4_FILE ) :: NCFILE
  character (len=*) :: sVariableName
  integer (c_int) :: iVariableType
  integer (c_int) :: iNumberOfDimensions
  integer (c_int), dimension(:) :: iDimIDs
  integer (c_int) :: iVarID

  call nf_trap( nc_def_var(ncid=NCFILE%iNCID,&
                           name=trim(fortran_to_c_string(sVariableName)), &
                           xtype=iVariableType, &
                           ndims=iNumberOfDimensions, &
                           dimidsp=iDimIDs, &
                           varidp=iVarID), &
                           __FILE__, __LINE__)

end function nf_define_variable

!----------------------------------------------------------------------

!! before this function is called, the values associated with NCFILE must be defined.

subroutine nf_define_variables( NCFILE )

  type (T_NETCDF4_FILE) :: NCFILE

  ! [ LOCALS ]
  integer (c_int) :: iStat
  integer (c_int) :: iIndex
  character (len=256) :: sDimName
  type (T_NETCDF_VARIABLE), pointer :: pNC_VAR

  !! note: the default number of variables for a simple archive file is 4:
  !! 0) time, 1) Y, 2) X, 3) variable of interest

  do iIndex = 0, NCFILE%iNumberOfVariables-1

    pNC_VAR => NCFILE%pNC_VAR(iIndex)

    call nf_trap( nc_def_var(ncid=NCFILE%iNCID,&
                             name=trim(fortran_to_c_string(pNC_VAR%sVariableName)), &
                             xtype=pNC_VAR%iNC_VarType, &
                             ndims=pNC_VAR%iNumberOfDimensions, &
                             dimidsp=pNC_VAR%iNC_DimID, &
                             varidp=pNC_VAR%iNC_VarID), &
                             __FILE__, __LINE__)

  enddo

end subroutine nf_define_variables

!----------------------------------------------------------------------

subroutine netcdf_rewrite_attribute(NCFILE, sVariableName, sAttributeName,       &
  sAttributeValue, iAttributeValue, rAttributeValue, dpAttributeValue)

  type (T_NETCDF4_FILE ) :: NCFILE
  character (len=*) :: sVariableName
  character (len=*) :: sAttributeName
  character (len=*), dimension(:), optional :: sAttributeValue
  integer (c_int), dimension(:), optional :: iAttributeValue
  real (c_float), dimension(:), optional :: rAttributeValue
  real (c_double), dimension(:), optional :: dpAttributeValue

  integer (c_int) :: iVarID

  ! put netCDF file into define mode again before attempting to redefine the attribute
  call nf_redef(NCFILE)

  iVarID = nf_get_varid(NCFILE, trim(sVariableName))
  
  if (present(sAttributeValue))     &
    call nf_put_attribute( NCFILE, iVarID, trim(sAttributeName)//c_null_char, sAttributeValue )
  
  if (present(iAttributeValue))     &
    call nf_put_attribute( NCFILE, iVarID, trim(sAttributeName)//c_null_char, iAttributeValue=iAttributeValue )
  
  if (present(rAttributeValue))     &
    call nf_put_attribute( NCFILE, iVarID, trim(sAttributeName)//c_null_char, rAttributeValue=rAttributeValue )
  
  if (present(dpAttributeValue))    &
    call nf_put_attribute( NCFILE, iVarID, trim(sAttributeName)//c_null_char, dpAttributeValue=dpAttributeValue )

end subroutine netcdf_rewrite_attribute

!----------------------------------------------------------------------

subroutine nf_put_attribute(NCFILE, iVarID, sAttributeName, &
  sAttributeValue, iAttributeValue, rAttributeValue, dpAttributeValue)

  type (T_NETCDF4_FILE ) :: NCFILE
  integer (c_int) :: iVarID
  character (len=*) :: sAttributeName
  character (len=*), dimension(:), optional :: sAttributeValue
  integer (c_int), dimension(:), optional :: iAttributeValue
  real (c_float), dimension(:), optional :: rAttributeValue
  real (c_double), dimension(:), optional :: dpAttributeValue

  ! [ LOCALS ]
  integer (c_size_t) :: iNumberOfAttributes

  if (present(sAttributeValue) ) then

    iNumberOfAttributes = size( sAttributeValue, 1)
    iNumberOfAttributes = int(len_trim(sAttributeValue(1)), c_size_t)

    call nf_trap( nc_put_att_text(ncid=NCFILE%iNCID, &
                    varid=iVarID, &
                    name=trim(sAttributeName), &
                    nlen=iNumberOfAttributes, &
                    tp=trim(sAttributeValue(1))), &
                    __FILE__, __LINE__)

  elseif (present(iAttributeValue) ) then

    iNumberOfAttributes = size( iAttributeValue, 1)

    call nf_trap( nc_put_att_int(ncid=NCFILE%iNCID, &
                    varid=iVarID, &
                    name=trim(sAttributeName), &
                    xtype=NC_INT, &
                    nlen=iNumberOfAttributes, &
                     ip=iAttributeValue), &
                     __FILE__, __LINE__)

  elseif (present(rAttributeValue) ) then

    iNumberOfAttributes = size( rAttributeValue, 1)

    call nf_trap( nc_put_att_float(ncid=NCFILE%iNCID, &
                    varid=iVarID, &
                    name=trim(sAttributeName), &
                    xtype=NC_FLOAT, &
                    nlen=iNumberOfAttributes, &
                    fp=rAttributeValue), &
                    __FILE__, __LINE__)

  elseif (present(dpAttributeValue) ) then

    iNumberOfAttributes = size( dpAttributeValue, 1)

    call nf_trap( nc_put_att_double(ncid=NCFILE%iNCID, &
                       varid=iVarID, &
                       name=trim(sAttributeName), &
                       xtype=NC_DOUBLE, &
                       nlen=iNumberOfAttributes, &
                       dp=dpAttributeValue), &
                       __FILE__, __LINE__)

  endif


end subroutine nf_put_attribute

!----------------------------------------------------------------------

subroutine nf_put_attributes(NCFILE)

  type (T_NETCDF4_FILE ) :: NCFILE

  ! [ LOCALS ]
  integer (c_size_t) :: iNumberOfAttributes
  type (T_NETCDF_VARIABLE), pointer :: pNC_VAR
  type (T_NETCDF_ATTRIBUTE), pointer :: pNC_ATT
  integer (c_int) :: iIndex
  integer (c_int) :: iIndex2
  integer (c_int) :: iStat
  integer (c_int) :: indx

  ! loop over variables
  do iIndex = 0, NCFILE%iNumberOfVariables-1

    pNC_VAR => NCFILE%pNC_VAR(iIndex)

    ! for each variable, loop over the associated attributes
    do iIndex2 = 0, pNC_VAR%iNumberOfAttributes-1

      pNC_ATT => pNC_VAR%pNC_ATT(iIndex2)

        select case (pNC_ATT%iNC_AttType)

          case (NC_DOUBLE)

            if (.not. allocated(pNC_ATT%dpAttValue) ) &
              call die("INTERNAL PROGRAMMING ERROR - attempt to use unallocated variable; " &
              //"attribute name: "//dquote(pNC_ATT%sAttributeName), &
              __FILE__, __LINE__)

            call nf_put_attribute(NCFILE=NCFILE, &
                iVarID=pNC_VAR%iNC_VarID, &
                sAttributeName=trim(pNC_ATT%sAttributeName)//c_null_char, &
                dpAttributeValue=pNC_ATT%dpAttValue)

          case (NC_INT)

            if (.not. allocated(pNC_ATT%iAttValue) ) &
              call die("INTERNAL PROGRAMMING ERROR - attempt to use unallocated variable; " &
              //"attribute name: "//dquote(pNC_ATT%sAttributeName), &
              __FILE__, __LINE__)

            call nf_put_attribute(NCFILE=NCFILE, &
                iVarID=pNC_VAR%iNC_VarID, &
                sAttributeName=trim(pNC_ATT%sAttributeName)//c_null_char, &
                iAttributeValue=pNC_ATT%iAttValue)

          case (NC_FLOAT)

            if (.not. allocated(pNC_ATT%rAttValue) ) &
              call die("INTERNAL PROGRAMMING ERROR - attempt to use unallocated variable; " &
              //"attribute name: "//dquote(pNC_ATT%sAttributeName), &
              __FILE__, __LINE__)

            call nf_put_attribute(NCFILE=NCFILE, &
                iVarID=pNC_VAR%iNC_VarID, &
                sAttributeName=trim(pNC_ATT%sAttributeName)//c_null_char, &
                rAttributeValue=pNC_ATT%rAttValue)

          case (NC_CHAR)

            if (.not. allocated(pNC_ATT%sAttValue) ) &
              call die("INTERNAL PROGRAMMING ERROR - attempt to use unallocated variable; " &
              //"attribute name: "//dquote(pNC_ATT%sAttributeName), &
              __FILE__, __LINE__)

            do indx=0,ubound(pNC_ATT%sAttValue, 1)

              call nf_put_attribute(NCFILE=NCFILE, &
                  iVarID=pNC_VAR%iNC_VarID, &
                  sAttributeName=trim(pNC_ATT%sAttributeName)//c_null_char, &
                  sAttributeValue=[trim(pNC_ATT%sAttValue(indx))//c_null_char])

            enddo

        end select

    enddo

  enddo

  ! now loop over global attributes
  do iIndex2 = 0, NCFILE%iNumberOfAttributes-1

    pNC_ATT => NCFILE%pNC_ATT(iIndex2)

    select case (pNC_ATT%iNC_AttType)

      case (NC_DOUBLE)

        if (.not. allocated(pNC_ATT%sAttValue) ) &
          call die("INTERNAL PROGRAMMING ERROR - attempt to use unallocated variable; " &
          //"attribute name: "//dquote(pNC_ATT%sAttributeName), &
          __FILE__, __LINE__)

        call nf_put_attribute(NCFILE=NCFILE, &
            iVarID=NC_GLOBAL, &
            sAttributeName=trim(pNC_ATT%sAttributeName)//c_null_char, &
            dpAttributeValue=pNC_ATT%dpAttValue)

      case (NC_INT)

        if (.not. allocated(pNC_ATT%sAttValue) ) &
          call die("INTERNAL PROGRAMMING ERROR - attempt to use unallocated variable; " &
          //"attribute name: "//dquote(pNC_ATT%sAttributeName), &
          __FILE__, __LINE__)

        call nf_put_attribute(NCFILE=NCFILE, &
            iVarID=NC_GLOBAL, &
            sAttributeName=trim(pNC_ATT%sAttributeName)//c_null_char, &
            iAttributeValue=pNC_ATT%iAttValue)

      case (NC_FLOAT)

        if (.not. allocated(pNC_ATT%sAttValue) ) &
          call die("INTERNAL PROGRAMMING ERROR - attempt to use unallocated variable; " &
          //"attribute name: "//dquote(pNC_ATT%sAttributeName), &
          __FILE__, __LINE__)

        call nf_put_attribute(NCFILE=NCFILE, &
            iVarID=NC_GLOBAL, &
            sAttributeName=trim(pNC_ATT%sAttributeName)//c_null_char, &
            rAttributeValue=pNC_ATT%rAttValue)

      case (NC_CHAR)

        if (.not. allocated(pNC_ATT%sAttValue) ) &
          call die("INTERNAL PROGRAMMING ERROR - attempt to use unallocated variable; " &
          //"attribute name: "//dquote(pNC_ATT%sAttributeName), &
          __FILE__, __LINE__)

        do indx=0, ubound(pNC_ATT%sAttValue, 1)

          call nf_put_attribute(NCFILE=NCFILE,                               &
              iVarID=NC_GLOBAL,                                              &
              sAttributeName=trim(pNC_ATT%sAttributeName)//c_null_char,      &
              sAttributeValue=[trim(pNC_ATT%sAttValue(indx))//c_null_char])

        enddo

    end select

  enddo

end subroutine nf_put_attributes

!----------------------------------------------------------------------

subroutine netcdf_put_variable_array(NCFILE, iVarID, iStart, iCount, iStride, &
   iValues, i2Values, rValues, dpValues)

  type (T_NETCDF4_FILE ) :: NCFILE
  integer (c_int) :: iVarID
  integer (c_size_t), dimension(:) :: iStart
  integer (c_size_t), dimension(:) :: iCount
  integer (c_size_t), dimension(:) :: iStride
  integer (c_int), dimension(:,:), optional :: iValues
  integer (c_short), dimension(:,:), optional :: i2Values
  real (c_float), dimension(:,:), optional :: rValues
  real (c_double), dimension(:,:), optional :: dpValues

  if (present(iValues) ) then

    call nf_trap(nc_put_vars_int(ncid=NCFILE%iNCID, &
                       varid=iVarID, &
                       startp=iStart, &
                       countp=iCount, &
                       stridep=iStride, &
                       vars=iValues), &
                       __FILE__, __LINE__)

  elseif (present(i2Values) ) then

    call nf_trap(nc_put_vars_short(ncid=NCFILE%iNCID, &
                       varid=iVarID, &
                       startp=iStart, &
                       countp=iCount, &
                       stridep=iStride, &
                       vars=i2Values), &
                       __FILE__, __LINE__)

  elseif (present(rValues) ) then

   call nf_trap(nc_put_vars_float(ncid=NCFILE%iNCID, &
                       varid=iVarID, &
                       startp=iStart, &
                       countp=iCount, &
                       stridep=iStride, &
                       vars=rValues), &
                       __FILE__, __LINE__)

  elseif (present(dpValues) ) then



    call nf_trap(nc_put_vars_double(ncid=NCFILE%iNCID, &
                       varid=iVarID, &
                       startp=iStart, &
                       countp=iCount, &
                       stridep=iStride, &
                       vars=dpValues), &
                       __FILE__, __LINE__)

  endif

end subroutine netcdf_put_variable_array

subroutine netcdf_put_packed_variable_array(NCFILE, iVarID, iStart, iCount, iStride, &
   lMask, iValues, iField, i2Values, i2Field, rValues, rField, dpValues, dpField)

  type (T_NETCDF4_FILE ) :: NCFILE
  integer (c_int) :: iVarID
  integer (c_size_t), dimension(:)            :: iStart
  integer (c_size_t), dimension(:)            :: iCount
  integer (c_size_t), dimension(:)         :: iStride
  logical (c_bool), dimension(:,:)            :: lMask
  integer (c_int), dimension(:), optional     :: iValues
  integer (c_int), dimension(:,:), optional   :: iField
  integer (c_short), dimension(:), optional   :: i2Values
  integer (c_short), dimension(:,:), optional :: i2Field
  real (c_float), dimension(:), optional      :: rValues
  real (c_float), dimension(:,:), optional    :: rField
  real (c_double), dimension(:), optional     :: dpValues
  real (c_double), dimension(:,:), optional   :: dpField

  if (present(iValues) ) then

    call nf_trap(nc_put_vars_int(ncid=NCFILE%iNCID, &
                       varid=iVarID, &
                       startp=iStart, &
                       countp=iCount, &
                       stridep=iStride, &
                       vars=unpack(iValues, lMask, iField)), &
                       __FILE__, __LINE__)

  elseif (present(i2Values) ) then

    call nf_trap(nc_put_vars_short(ncid=NCFILE%iNCID, &
                       varid=iVarID, &
                       startp=iStart, &
                       countp=iCount, &
                       stridep=iStride, &
                       vars=unpack(i2Values, lMask, i2Field)), &
                       __FILE__, __LINE__)

  elseif (present(rValues) ) then

   call nf_trap(nc_put_vars_float(ncid=NCFILE%iNCID, &
                       varid=iVarID, &
                       startp=iStart, &
                       countp=iCount, &
                       stridep=iStride, &
                       vars=unpack(rValues, lMask, rField)), &
                       __FILE__, __LINE__)

  elseif (present(dpValues) ) then

    call nf_trap(nc_put_vars_double(ncid=NCFILE%iNCID, &
                       varid=iVarID, &
                       startp=iStart, &
                       countp=iCount, &
                       stridep=iStride, &
                       vars=unpack(dpValues, lMask, dpField)), &
                       __FILE__, __LINE__)

  endif

end subroutine netcdf_put_packed_variable_array


subroutine netcdf_put_variable_vector(NCFILE, iVarID, iStart, iCount, iStride, &
   iValues, i2Values, rValues, dpValues)

  type (T_NETCDF4_FILE ) :: NCFILE
  integer (c_int) :: iVarID
  integer (c_size_t), dimension(:) :: iStart
  integer (c_size_t), dimension(:) :: iCount
  integer (c_size_t), dimension(:) :: iStride
  integer (c_int), dimension(:), optional :: iValues
  integer (c_short), dimension(:), optional :: i2Values
  real (c_float), dimension(:), optional :: rValues
  real (c_double), dimension(:), optional :: dpValues

  if (present(iValues) ) then

    call nf_trap(nc_put_vars_int(ncid=NCFILE%iNCID, &
                       varid=iVarID, &
                       startp=iStart, &
                       countp=iCount, &
                       stridep=iStride, &
                       vars=iValues), &
                       __FILE__, __LINE__)

  elseif (present(i2Values) ) then

    call nf_trap(nc_put_vars_short(ncid=NCFILE%iNCID, &
                       varid=iVarID, &
                       startp=iStart, &
                       countp=iCount, &
                       stridep=iStride, &
                       vars=i2Values), &
                       __FILE__, __LINE__)

  elseif (present(rValues) ) then

    call nf_trap(nc_put_vars_float(ncid=NCFILE%iNCID, &
                       varid=iVarID, &
                       startp=iStart, &
                       countp=iCount, &
                       stridep=iStride, &
                       vars=rValues), &
                       __FILE__, __LINE__)

  elseif (present(dpValues) ) then

    call nf_trap(nc_put_vars_double(ncid=NCFILE%iNCID, &
                       varid=iVarID, &
                       startp=iStart, &
                       countp=iCount, &
                       stridep=iStride, &
                       vars=dpValues), &
                       __FILE__, __LINE__, NCFILE%sFilename )

  endif

end subroutine netcdf_put_variable_vector


end module netcdf4_support
